#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ProblemType:
  UNDEFINED = 0
  BINARY_CLASSIFICATION = 1
  MULTICLASS_CLASSIFICATION = 2
  REGRESSION = 3
  CLUSTERING = 4
  RECOMMENDATION = 5

  _VALUES_TO_NAMES = {
    0: "UNDEFINED",
    1: "BINARY_CLASSIFICATION",
    2: "MULTICLASS_CLASSIFICATION",
    3: "REGRESSION",
    4: "CLUSTERING",
    5: "RECOMMENDATION",
  }

  _NAMES_TO_VALUES = {
    "UNDEFINED": 0,
    "BINARY_CLASSIFICATION": 1,
    "MULTICLASS_CLASSIFICATION": 2,
    "REGRESSION": 3,
    "CLUSTERING": 4,
    "RECOMMENDATION": 5,
  }

class ModelCompMetric:
  PROJECT = 0
  EXPERIMENT_RUN = 1
  MODEL_TYPE = 2
  PROBLEM_TYPE = 3
  RMSE = 4
  EXPLAINED_VARIANCE = 5
  R2 = 6

  _VALUES_TO_NAMES = {
    0: "PROJECT",
    1: "EXPERIMENT_RUN",
    2: "MODEL_TYPE",
    3: "PROBLEM_TYPE",
    4: "RMSE",
    5: "EXPLAINED_VARIANCE",
    6: "R2",
  }

  _NAMES_TO_VALUES = {
    "PROJECT": 0,
    "EXPERIMENT_RUN": 1,
    "MODEL_TYPE": 2,
    "PROBLEM_TYPE": 3,
    "RMSE": 4,
    "EXPLAINED_VARIANCE": 5,
    "R2": 6,
  }

class ModelRankMetric:
  RMSE = 0
  EXPLAINED_VARIANCE = 1
  R2 = 2

  _VALUES_TO_NAMES = {
    0: "RMSE",
    1: "EXPLAINED_VARIANCE",
    2: "R2",
  }

  _NAMES_TO_VALUES = {
    "RMSE": 0,
    "EXPLAINED_VARIANCE": 1,
    "R2": 2,
  }


class Project:
  """
  Attributes:
   - id
   - name
   - author
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, -1, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'author', None, None, ), # 3
    (4, TType.STRING, 'description', None, None, ), # 4
  )

  def __init__(self, id=thrift_spec[1][4], name=None, author=None, description=None,):
    self.id = id
    self.name = name
    self.author = author
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.author = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Project')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.author is not None:
      oprot.writeFieldBegin('author', TType.STRING, 3)
      oprot.writeString(self.author)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 4)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.author)
    value = (value * 31) ^ hash(self.description)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Experiment:
  """
  Attributes:
   - id
   - projectId
   - name
   - description
   - isDefault
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, -1, ), # 1
    (2, TType.I32, 'projectId', None, None, ), # 2
    (3, TType.STRING, 'name', None, None, ), # 3
    (4, TType.STRING, 'description', None, None, ), # 4
    (5, TType.BOOL, 'isDefault', None, False, ), # 5
  )

  def __init__(self, id=thrift_spec[1][4], projectId=None, name=None, description=None, isDefault=thrift_spec[5][4],):
    self.id = id
    self.projectId = projectId
    self.name = name
    self.description = description
    self.isDefault = isDefault

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.projectId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.isDefault = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Experiment')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.projectId is not None:
      oprot.writeFieldBegin('projectId', TType.I32, 2)
      oprot.writeI32(self.projectId)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 4)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.isDefault is not None:
      oprot.writeFieldBegin('isDefault', TType.BOOL, 5)
      oprot.writeBool(self.isDefault)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.projectId)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.isDefault)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExperimentRun:
  """
  Attributes:
   - id
   - experimentId
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, -1, ), # 1
    (2, TType.I32, 'experimentId', None, None, ), # 2
    (3, TType.STRING, 'description', None, None, ), # 3
  )

  def __init__(self, id=thrift_spec[1][4], experimentId=None, description=None,):
    self.id = id
    self.experimentId = experimentId
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.experimentId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.description = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentRun')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.experimentId is not None:
      oprot.writeFieldBegin('experimentId', TType.I32, 2)
      oprot.writeI32(self.experimentId)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 3)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.experimentId)
    value = (value * 31) ^ hash(self.description)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataFrameColumn:
  """
  Attributes:
   - name
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
  )

  def __init__(self, name=None, type=None,):
    self.name = name
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataFrameColumn')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataFrame:
  """
  Attributes:
   - id
   - schema
   - numRows
   - tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, -1, ), # 1
    (2, TType.LIST, 'schema', (TType.STRUCT,(DataFrameColumn, DataFrameColumn.thrift_spec)), None, ), # 2
    (3, TType.I32, 'numRows', None, None, ), # 3
    (4, TType.STRING, 'tag', None, "", ), # 4
  )

  def __init__(self, id=thrift_spec[1][4], schema=None, numRows=None, tag=thrift_spec[4][4],):
    self.id = id
    self.schema = schema
    self.numRows = numRows
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.schema = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = DataFrameColumn()
            _elem5.read(iprot)
            self.schema.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.numRows = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tag = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataFrame')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.schema))
      for iter6 in self.schema:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.numRows is not None:
      oprot.writeFieldBegin('numRows', TType.I32, 3)
      oprot.writeI32(self.numRows)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 4)
      oprot.writeString(self.tag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.schema)
    value = (value * 31) ^ hash(self.numRows)
    value = (value * 31) ^ hash(self.tag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class HyperParameter:
  """
  Attributes:
   - name
   - value
   - type
   - min
   - max
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
    (3, TType.STRING, 'type', None, None, ), # 3
    (4, TType.DOUBLE, 'min', None, None, ), # 4
    (5, TType.DOUBLE, 'max', None, None, ), # 5
  )

  def __init__(self, name=None, value=None, type=None, min=None, max=None,):
    self.name = name
    self.value = value
    self.type = type
    self.min = min
    self.max = max

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.min = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.max = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('HyperParameter')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 3)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.min is not None:
      oprot.writeFieldBegin('min', TType.DOUBLE, 4)
      oprot.writeDouble(self.min)
      oprot.writeFieldEnd()
    if self.max is not None:
      oprot.writeFieldBegin('max', TType.DOUBLE, 5)
      oprot.writeDouble(self.max)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.min)
    value = (value * 31) ^ hash(self.max)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProjectEvent:
  """
  Attributes:
   - project
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'project', (Project, Project.thrift_spec), None, ), # 1
  )

  def __init__(self, project=None,):
    self.project = project

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.project = Project()
          self.project.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProjectEvent')
    if self.project is not None:
      oprot.writeFieldBegin('project', TType.STRUCT, 1)
      self.project.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.project)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProjectEventResponse:
  """
  Attributes:
   - projectId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'projectId', None, None, ), # 1
  )

  def __init__(self, projectId=None,):
    self.projectId = projectId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.projectId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProjectEventResponse')
    if self.projectId is not None:
      oprot.writeFieldBegin('projectId', TType.I32, 1)
      oprot.writeI32(self.projectId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.projectId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExperimentEvent:
  """
  Attributes:
   - experiment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'experiment', (Experiment, Experiment.thrift_spec), None, ), # 1
  )

  def __init__(self, experiment=None,):
    self.experiment = experiment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.experiment = Experiment()
          self.experiment.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentEvent')
    if self.experiment is not None:
      oprot.writeFieldBegin('experiment', TType.STRUCT, 1)
      self.experiment.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.experiment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExperimentEventResponse:
  """
  Attributes:
   - experimentId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'experimentId', None, None, ), # 1
  )

  def __init__(self, experimentId=None,):
    self.experimentId = experimentId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.experimentId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentEventResponse')
    if self.experimentId is not None:
      oprot.writeFieldBegin('experimentId', TType.I32, 1)
      oprot.writeI32(self.experimentId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.experimentId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExperimentRunEvent:
  """
  Attributes:
   - experimentRun
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'experimentRun', (ExperimentRun, ExperimentRun.thrift_spec), None, ), # 1
  )

  def __init__(self, experimentRun=None,):
    self.experimentRun = experimentRun

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.experimentRun = ExperimentRun()
          self.experimentRun.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentRunEvent')
    if self.experimentRun is not None:
      oprot.writeFieldBegin('experimentRun', TType.STRUCT, 1)
      self.experimentRun.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.experimentRun)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExperimentRunEventResponse:
  """
  Attributes:
   - experimentRunId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'experimentRunId', None, None, ), # 1
  )

  def __init__(self, experimentRunId=None,):
    self.experimentRunId = experimentRunId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentRunEventResponse')
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 1)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.experimentRunId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TransformerSpec:
  """
  Attributes:
   - id
   - transformerType
   - features
   - hyperparameters
   - tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, -1, ), # 1
    (2, TType.STRING, 'transformerType', None, None, ), # 2
    (3, TType.LIST, 'features', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'hyperparameters', (TType.STRUCT,(HyperParameter, HyperParameter.thrift_spec)), None, ), # 4
    (5, TType.STRING, 'tag', None, "", ), # 5
  )

  def __init__(self, id=thrift_spec[1][4], transformerType=None, features=None, hyperparameters=None, tag=thrift_spec[5][4],):
    self.id = id
    self.transformerType = transformerType
    self.features = features
    self.hyperparameters = hyperparameters
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.transformerType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.features = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString()
            self.features.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.hyperparameters = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = HyperParameter()
            _elem18.read(iprot)
            self.hyperparameters.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.tag = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TransformerSpec')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.transformerType is not None:
      oprot.writeFieldBegin('transformerType', TType.STRING, 2)
      oprot.writeString(self.transformerType)
      oprot.writeFieldEnd()
    if self.features is not None:
      oprot.writeFieldBegin('features', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.features))
      for iter19 in self.features:
        oprot.writeString(iter19)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.hyperparameters is not None:
      oprot.writeFieldBegin('hyperparameters', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.hyperparameters))
      for iter20 in self.hyperparameters:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 5)
      oprot.writeString(self.tag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.transformerType)
    value = (value * 31) ^ hash(self.features)
    value = (value * 31) ^ hash(self.hyperparameters)
    value = (value * 31) ^ hash(self.tag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Transformer:
  """
  Attributes:
   - id
   - weights
   - transformerType
   - tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, -1, ), # 1
    (2, TType.LIST, 'weights', (TType.DOUBLE,None), None, ), # 2
    (3, TType.STRING, 'transformerType', None, None, ), # 3
    (4, TType.STRING, 'tag', None, "", ), # 4
  )

  def __init__(self, id=thrift_spec[1][4], weights=None, transformerType=None, tag=thrift_spec[4][4],):
    self.id = id
    self.weights = weights
    self.transformerType = transformerType
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.weights = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readDouble()
            self.weights.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.transformerType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tag = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Transformer')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.weights is not None:
      oprot.writeFieldBegin('weights', TType.LIST, 2)
      oprot.writeListBegin(TType.DOUBLE, len(self.weights))
      for iter27 in self.weights:
        oprot.writeDouble(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.transformerType is not None:
      oprot.writeFieldBegin('transformerType', TType.STRING, 3)
      oprot.writeString(self.transformerType)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRING, 4)
      oprot.writeString(self.tag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.weights)
    value = (value * 31) ^ hash(self.transformerType)
    value = (value * 31) ^ hash(self.tag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ModelResponse:
  """
  Attributes:
   - id
   - experimentRunId
   - experimentId
   - projectId
   - trainingDataFrame
   - specification
   - problemType
   - featureColumns
   - labelColumns
   - predictionColumns
   - metrics
   - annotations
   - sha
   - filepath
   - linearModelData
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.I32, 'experimentRunId', None, None, ), # 2
    (3, TType.I32, 'experimentId', None, None, ), # 3
    (4, TType.I32, 'projectId', None, None, ), # 4
    (5, TType.STRUCT, 'trainingDataFrame', (DataFrame, DataFrame.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'specification', (TransformerSpec, TransformerSpec.thrift_spec), None, ), # 6
    (7, TType.I32, 'problemType', None, None, ), # 7
    (8, TType.LIST, 'featureColumns', (TType.STRING,None), None, ), # 8
    (9, TType.LIST, 'labelColumns', (TType.STRING,None), None, ), # 9
    (10, TType.LIST, 'predictionColumns', (TType.STRING,None), None, ), # 10
    (11, TType.MAP, 'metrics', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.DOUBLE,None)), None, ), # 11
    (12, TType.LIST, 'annotations', (TType.STRING,None), None, ), # 12
    (13, TType.STRING, 'sha', None, None, ), # 13
    (14, TType.STRING, 'filepath', None, None, ), # 14
    (15, TType.STRUCT, 'linearModelData', (LinearModel, LinearModel.thrift_spec), None, ), # 15
  )

  def __init__(self, id=None, experimentRunId=None, experimentId=None, projectId=None, trainingDataFrame=None, specification=None, problemType=None, featureColumns=None, labelColumns=None, predictionColumns=None, metrics=None, annotations=None, sha=None, filepath=None, linearModelData=None,):
    self.id = id
    self.experimentRunId = experimentRunId
    self.experimentId = experimentId
    self.projectId = projectId
    self.trainingDataFrame = trainingDataFrame
    self.specification = specification
    self.problemType = problemType
    self.featureColumns = featureColumns
    self.labelColumns = labelColumns
    self.predictionColumns = predictionColumns
    self.metrics = metrics
    self.annotations = annotations
    self.sha = sha
    self.filepath = filepath
    self.linearModelData = linearModelData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.experimentId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.projectId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.trainingDataFrame = DataFrame()
          self.trainingDataFrame.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.specification = TransformerSpec()
          self.specification.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.problemType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.featureColumns = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readString()
            self.featureColumns.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.labelColumns = []
          (_etype37, _size34) = iprot.readListBegin()
          for _i38 in xrange(_size34):
            _elem39 = iprot.readString()
            self.labelColumns.append(_elem39)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.predictionColumns = []
          (_etype43, _size40) = iprot.readListBegin()
          for _i44 in xrange(_size40):
            _elem45 = iprot.readString()
            self.predictionColumns.append(_elem45)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.metrics = {}
          (_ktype47, _vtype48, _size46 ) = iprot.readMapBegin()
          for _i50 in xrange(_size46):
            _key51 = iprot.readString()
            _val52 = {}
            (_ktype54, _vtype55, _size53 ) = iprot.readMapBegin()
            for _i57 in xrange(_size53):
              _key58 = iprot.readI32()
              _val59 = iprot.readDouble()
              _val52[_key58] = _val59
            iprot.readMapEnd()
            self.metrics[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.annotations = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = iprot.readString()
            self.annotations.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.sha = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.filepath = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.linearModelData = LinearModel()
          self.linearModelData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ModelResponse')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 2)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    if self.experimentId is not None:
      oprot.writeFieldBegin('experimentId', TType.I32, 3)
      oprot.writeI32(self.experimentId)
      oprot.writeFieldEnd()
    if self.projectId is not None:
      oprot.writeFieldBegin('projectId', TType.I32, 4)
      oprot.writeI32(self.projectId)
      oprot.writeFieldEnd()
    if self.trainingDataFrame is not None:
      oprot.writeFieldBegin('trainingDataFrame', TType.STRUCT, 5)
      self.trainingDataFrame.write(oprot)
      oprot.writeFieldEnd()
    if self.specification is not None:
      oprot.writeFieldBegin('specification', TType.STRUCT, 6)
      self.specification.write(oprot)
      oprot.writeFieldEnd()
    if self.problemType is not None:
      oprot.writeFieldBegin('problemType', TType.I32, 7)
      oprot.writeI32(self.problemType)
      oprot.writeFieldEnd()
    if self.featureColumns is not None:
      oprot.writeFieldBegin('featureColumns', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.featureColumns))
      for iter66 in self.featureColumns:
        oprot.writeString(iter66)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.labelColumns is not None:
      oprot.writeFieldBegin('labelColumns', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.labelColumns))
      for iter67 in self.labelColumns:
        oprot.writeString(iter67)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.predictionColumns is not None:
      oprot.writeFieldBegin('predictionColumns', TType.LIST, 10)
      oprot.writeListBegin(TType.STRING, len(self.predictionColumns))
      for iter68 in self.predictionColumns:
        oprot.writeString(iter68)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.metrics is not None:
      oprot.writeFieldBegin('metrics', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.metrics))
      for kiter69,viter70 in self.metrics.items():
        oprot.writeString(kiter69)
        oprot.writeMapBegin(TType.I32, TType.DOUBLE, len(viter70))
        for kiter71,viter72 in viter70.items():
          oprot.writeI32(kiter71)
          oprot.writeDouble(viter72)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.annotations is not None:
      oprot.writeFieldBegin('annotations', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.annotations))
      for iter73 in self.annotations:
        oprot.writeString(iter73)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sha is not None:
      oprot.writeFieldBegin('sha', TType.STRING, 13)
      oprot.writeString(self.sha)
      oprot.writeFieldEnd()
    if self.filepath is not None:
      oprot.writeFieldBegin('filepath', TType.STRING, 14)
      oprot.writeString(self.filepath)
      oprot.writeFieldEnd()
    if self.linearModelData is not None:
      oprot.writeFieldBegin('linearModelData', TType.STRUCT, 15)
      self.linearModelData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.experimentRunId)
    value = (value * 31) ^ hash(self.experimentId)
    value = (value * 31) ^ hash(self.projectId)
    value = (value * 31) ^ hash(self.trainingDataFrame)
    value = (value * 31) ^ hash(self.specification)
    value = (value * 31) ^ hash(self.problemType)
    value = (value * 31) ^ hash(self.featureColumns)
    value = (value * 31) ^ hash(self.labelColumns)
    value = (value * 31) ^ hash(self.predictionColumns)
    value = (value * 31) ^ hash(self.metrics)
    value = (value * 31) ^ hash(self.annotations)
    value = (value * 31) ^ hash(self.sha)
    value = (value * 31) ^ hash(self.filepath)
    value = (value * 31) ^ hash(self.linearModelData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FitEvent:
  """
  Attributes:
   - df
   - spec
   - model
   - featureColumns
   - predictionColumns
   - labelColumns
   - experimentRunId
   - problemType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'df', (DataFrame, DataFrame.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'spec', (TransformerSpec, TransformerSpec.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'model', (Transformer, Transformer.thrift_spec), None, ), # 3
    (4, TType.LIST, 'featureColumns', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'predictionColumns', (TType.STRING,None), None, ), # 5
    (6, TType.LIST, 'labelColumns', (TType.STRING,None), None, ), # 6
    (7, TType.I32, 'experimentRunId', None, None, ), # 7
    (8, TType.I32, 'problemType', None,     0, ), # 8
  )

  def __init__(self, df=None, spec=None, model=None, featureColumns=None, predictionColumns=None, labelColumns=None, experimentRunId=None, problemType=thrift_spec[8][4],):
    self.df = df
    self.spec = spec
    self.model = model
    self.featureColumns = featureColumns
    self.predictionColumns = predictionColumns
    self.labelColumns = labelColumns
    self.experimentRunId = experimentRunId
    self.problemType = problemType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.df = DataFrame()
          self.df.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.spec = TransformerSpec()
          self.spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.model = Transformer()
          self.model.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.featureColumns = []
          (_etype77, _size74) = iprot.readListBegin()
          for _i78 in xrange(_size74):
            _elem79 = iprot.readString()
            self.featureColumns.append(_elem79)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.predictionColumns = []
          (_etype83, _size80) = iprot.readListBegin()
          for _i84 in xrange(_size80):
            _elem85 = iprot.readString()
            self.predictionColumns.append(_elem85)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.labelColumns = []
          (_etype89, _size86) = iprot.readListBegin()
          for _i90 in xrange(_size86):
            _elem91 = iprot.readString()
            self.labelColumns.append(_elem91)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.problemType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FitEvent')
    if self.df is not None:
      oprot.writeFieldBegin('df', TType.STRUCT, 1)
      self.df.write(oprot)
      oprot.writeFieldEnd()
    if self.spec is not None:
      oprot.writeFieldBegin('spec', TType.STRUCT, 2)
      self.spec.write(oprot)
      oprot.writeFieldEnd()
    if self.model is not None:
      oprot.writeFieldBegin('model', TType.STRUCT, 3)
      self.model.write(oprot)
      oprot.writeFieldEnd()
    if self.featureColumns is not None:
      oprot.writeFieldBegin('featureColumns', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.featureColumns))
      for iter92 in self.featureColumns:
        oprot.writeString(iter92)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.predictionColumns is not None:
      oprot.writeFieldBegin('predictionColumns', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.predictionColumns))
      for iter93 in self.predictionColumns:
        oprot.writeString(iter93)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.labelColumns is not None:
      oprot.writeFieldBegin('labelColumns', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.labelColumns))
      for iter94 in self.labelColumns:
        oprot.writeString(iter94)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 7)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    if self.problemType is not None:
      oprot.writeFieldBegin('problemType', TType.I32, 8)
      oprot.writeI32(self.problemType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.df)
    value = (value * 31) ^ hash(self.spec)
    value = (value * 31) ^ hash(self.model)
    value = (value * 31) ^ hash(self.featureColumns)
    value = (value * 31) ^ hash(self.predictionColumns)
    value = (value * 31) ^ hash(self.labelColumns)
    value = (value * 31) ^ hash(self.experimentRunId)
    value = (value * 31) ^ hash(self.problemType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LinearModelTerm:
  """
  Attributes:
   - coefficient
   - tStat
   - stdErr
   - pValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'coefficient', None, None, ), # 1
    (2, TType.DOUBLE, 'tStat', None, None, ), # 2
    (3, TType.DOUBLE, 'stdErr', None, None, ), # 3
    (4, TType.DOUBLE, 'pValue', None, None, ), # 4
  )

  def __init__(self, coefficient=None, tStat=None, stdErr=None, pValue=None,):
    self.coefficient = coefficient
    self.tStat = tStat
    self.stdErr = stdErr
    self.pValue = pValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.coefficient = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.tStat = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.stdErr = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.pValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LinearModelTerm')
    if self.coefficient is not None:
      oprot.writeFieldBegin('coefficient', TType.DOUBLE, 1)
      oprot.writeDouble(self.coefficient)
      oprot.writeFieldEnd()
    if self.tStat is not None:
      oprot.writeFieldBegin('tStat', TType.DOUBLE, 2)
      oprot.writeDouble(self.tStat)
      oprot.writeFieldEnd()
    if self.stdErr is not None:
      oprot.writeFieldBegin('stdErr', TType.DOUBLE, 3)
      oprot.writeDouble(self.stdErr)
      oprot.writeFieldEnd()
    if self.pValue is not None:
      oprot.writeFieldBegin('pValue', TType.DOUBLE, 4)
      oprot.writeDouble(self.pValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.coefficient)
    value = (value * 31) ^ hash(self.tStat)
    value = (value * 31) ^ hash(self.stdErr)
    value = (value * 31) ^ hash(self.pValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LinearModel:
  """
  Attributes:
   - interceptTerm
   - featureTerms
   - objectiveHistory
   - rmse
   - explainedVariance
   - r2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'interceptTerm', (LinearModelTerm, LinearModelTerm.thrift_spec), None, ), # 1
    (2, TType.LIST, 'featureTerms', (TType.STRUCT,(LinearModelTerm, LinearModelTerm.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'objectiveHistory', (TType.DOUBLE,None), None, ), # 3
    (4, TType.DOUBLE, 'rmse', None, None, ), # 4
    (5, TType.DOUBLE, 'explainedVariance', None, None, ), # 5
    (6, TType.DOUBLE, 'r2', None, None, ), # 6
  )

  def __init__(self, interceptTerm=None, featureTerms=None, objectiveHistory=None, rmse=None, explainedVariance=None, r2=None,):
    self.interceptTerm = interceptTerm
    self.featureTerms = featureTerms
    self.objectiveHistory = objectiveHistory
    self.rmse = rmse
    self.explainedVariance = explainedVariance
    self.r2 = r2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.interceptTerm = LinearModelTerm()
          self.interceptTerm.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.featureTerms = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in xrange(_size95):
            _elem100 = LinearModelTerm()
            _elem100.read(iprot)
            self.featureTerms.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.objectiveHistory = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = iprot.readDouble()
            self.objectiveHistory.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.rmse = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.explainedVariance = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.r2 = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LinearModel')
    if self.interceptTerm is not None:
      oprot.writeFieldBegin('interceptTerm', TType.STRUCT, 1)
      self.interceptTerm.write(oprot)
      oprot.writeFieldEnd()
    if self.featureTerms is not None:
      oprot.writeFieldBegin('featureTerms', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.featureTerms))
      for iter107 in self.featureTerms:
        iter107.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.objectiveHistory is not None:
      oprot.writeFieldBegin('objectiveHistory', TType.LIST, 3)
      oprot.writeListBegin(TType.DOUBLE, len(self.objectiveHistory))
      for iter108 in self.objectiveHistory:
        oprot.writeDouble(iter108)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rmse is not None:
      oprot.writeFieldBegin('rmse', TType.DOUBLE, 4)
      oprot.writeDouble(self.rmse)
      oprot.writeFieldEnd()
    if self.explainedVariance is not None:
      oprot.writeFieldBegin('explainedVariance', TType.DOUBLE, 5)
      oprot.writeDouble(self.explainedVariance)
      oprot.writeFieldEnd()
    if self.r2 is not None:
      oprot.writeFieldBegin('r2', TType.DOUBLE, 6)
      oprot.writeDouble(self.r2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.interceptTerm)
    value = (value * 31) ^ hash(self.featureTerms)
    value = (value * 31) ^ hash(self.objectiveHistory)
    value = (value * 31) ^ hash(self.rmse)
    value = (value * 31) ^ hash(self.explainedVariance)
    value = (value * 31) ^ hash(self.r2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FitEventResponse:
  """
  Attributes:
   - dfId
   - specId
   - modelId
   - eventId
   - fitEventId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dfId', None, None, ), # 1
    (2, TType.I32, 'specId', None, None, ), # 2
    (3, TType.I32, 'modelId', None, None, ), # 3
    (4, TType.I32, 'eventId', None, None, ), # 4
    (5, TType.I32, 'fitEventId', None, None, ), # 5
  )

  def __init__(self, dfId=None, specId=None, modelId=None, eventId=None, fitEventId=None,):
    self.dfId = dfId
    self.specId = specId
    self.modelId = modelId
    self.eventId = eventId
    self.fitEventId = fitEventId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dfId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.specId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.modelId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.fitEventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FitEventResponse')
    if self.dfId is not None:
      oprot.writeFieldBegin('dfId', TType.I32, 1)
      oprot.writeI32(self.dfId)
      oprot.writeFieldEnd()
    if self.specId is not None:
      oprot.writeFieldBegin('specId', TType.I32, 2)
      oprot.writeI32(self.specId)
      oprot.writeFieldEnd()
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.I32, 3)
      oprot.writeI32(self.modelId)
      oprot.writeFieldEnd()
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I32, 4)
      oprot.writeI32(self.eventId)
      oprot.writeFieldEnd()
    if self.fitEventId is not None:
      oprot.writeFieldBegin('fitEventId', TType.I32, 5)
      oprot.writeI32(self.fitEventId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dfId)
    value = (value * 31) ^ hash(self.specId)
    value = (value * 31) ^ hash(self.modelId)
    value = (value * 31) ^ hash(self.eventId)
    value = (value * 31) ^ hash(self.fitEventId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetricEvent:
  """
  Attributes:
   - df
   - model
   - metricType
   - metricValue
   - labelCol
   - predictionCol
   - experimentRunId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'df', (DataFrame, DataFrame.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'model', (Transformer, Transformer.thrift_spec), None, ), # 2
    (3, TType.STRING, 'metricType', None, None, ), # 3
    (4, TType.DOUBLE, 'metricValue', None, None, ), # 4
    (5, TType.STRING, 'labelCol', None, None, ), # 5
    (6, TType.STRING, 'predictionCol', None, None, ), # 6
    (7, TType.I32, 'experimentRunId', None, None, ), # 7
  )

  def __init__(self, df=None, model=None, metricType=None, metricValue=None, labelCol=None, predictionCol=None, experimentRunId=None,):
    self.df = df
    self.model = model
    self.metricType = metricType
    self.metricValue = metricValue
    self.labelCol = labelCol
    self.predictionCol = predictionCol
    self.experimentRunId = experimentRunId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.df = DataFrame()
          self.df.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.model = Transformer()
          self.model.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.metricType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.metricValue = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.labelCol = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.predictionCol = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetricEvent')
    if self.df is not None:
      oprot.writeFieldBegin('df', TType.STRUCT, 1)
      self.df.write(oprot)
      oprot.writeFieldEnd()
    if self.model is not None:
      oprot.writeFieldBegin('model', TType.STRUCT, 2)
      self.model.write(oprot)
      oprot.writeFieldEnd()
    if self.metricType is not None:
      oprot.writeFieldBegin('metricType', TType.STRING, 3)
      oprot.writeString(self.metricType)
      oprot.writeFieldEnd()
    if self.metricValue is not None:
      oprot.writeFieldBegin('metricValue', TType.DOUBLE, 4)
      oprot.writeDouble(self.metricValue)
      oprot.writeFieldEnd()
    if self.labelCol is not None:
      oprot.writeFieldBegin('labelCol', TType.STRING, 5)
      oprot.writeString(self.labelCol)
      oprot.writeFieldEnd()
    if self.predictionCol is not None:
      oprot.writeFieldBegin('predictionCol', TType.STRING, 6)
      oprot.writeString(self.predictionCol)
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 7)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.df)
    value = (value * 31) ^ hash(self.model)
    value = (value * 31) ^ hash(self.metricType)
    value = (value * 31) ^ hash(self.metricValue)
    value = (value * 31) ^ hash(self.labelCol)
    value = (value * 31) ^ hash(self.predictionCol)
    value = (value * 31) ^ hash(self.experimentRunId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MetricEventResponse:
  """
  Attributes:
   - modelId
   - dfId
   - eventId
   - metricEventId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId', None, None, ), # 1
    (2, TType.I32, 'dfId', None, None, ), # 2
    (3, TType.I32, 'eventId', None, None, ), # 3
    (4, TType.I32, 'metricEventId', None, None, ), # 4
  )

  def __init__(self, modelId=None, dfId=None, eventId=None, metricEventId=None,):
    self.modelId = modelId
    self.dfId = dfId
    self.eventId = eventId
    self.metricEventId = metricEventId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dfId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.eventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.metricEventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MetricEventResponse')
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.I32, 1)
      oprot.writeI32(self.modelId)
      oprot.writeFieldEnd()
    if self.dfId is not None:
      oprot.writeFieldBegin('dfId', TType.I32, 2)
      oprot.writeI32(self.dfId)
      oprot.writeFieldEnd()
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I32, 3)
      oprot.writeI32(self.eventId)
      oprot.writeFieldEnd()
    if self.metricEventId is not None:
      oprot.writeFieldBegin('metricEventId', TType.I32, 4)
      oprot.writeI32(self.metricEventId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId)
    value = (value * 31) ^ hash(self.dfId)
    value = (value * 31) ^ hash(self.eventId)
    value = (value * 31) ^ hash(self.metricEventId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TransformEvent:
  """
  Attributes:
   - oldDataFrame
   - newDataFrame
   - transformer
   - inputColumns
   - outputColumns
   - experimentRunId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'oldDataFrame', (DataFrame, DataFrame.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'newDataFrame', (DataFrame, DataFrame.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transformer', (Transformer, Transformer.thrift_spec), None, ), # 3
    (4, TType.LIST, 'inputColumns', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'outputColumns', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'experimentRunId', None, None, ), # 6
  )

  def __init__(self, oldDataFrame=None, newDataFrame=None, transformer=None, inputColumns=None, outputColumns=None, experimentRunId=None,):
    self.oldDataFrame = oldDataFrame
    self.newDataFrame = newDataFrame
    self.transformer = transformer
    self.inputColumns = inputColumns
    self.outputColumns = outputColumns
    self.experimentRunId = experimentRunId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.oldDataFrame = DataFrame()
          self.oldDataFrame.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.newDataFrame = DataFrame()
          self.newDataFrame.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transformer = Transformer()
          self.transformer.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.inputColumns = []
          (_etype112, _size109) = iprot.readListBegin()
          for _i113 in xrange(_size109):
            _elem114 = iprot.readString()
            self.inputColumns.append(_elem114)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.outputColumns = []
          (_etype118, _size115) = iprot.readListBegin()
          for _i119 in xrange(_size115):
            _elem120 = iprot.readString()
            self.outputColumns.append(_elem120)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TransformEvent')
    if self.oldDataFrame is not None:
      oprot.writeFieldBegin('oldDataFrame', TType.STRUCT, 1)
      self.oldDataFrame.write(oprot)
      oprot.writeFieldEnd()
    if self.newDataFrame is not None:
      oprot.writeFieldBegin('newDataFrame', TType.STRUCT, 2)
      self.newDataFrame.write(oprot)
      oprot.writeFieldEnd()
    if self.transformer is not None:
      oprot.writeFieldBegin('transformer', TType.STRUCT, 3)
      self.transformer.write(oprot)
      oprot.writeFieldEnd()
    if self.inputColumns is not None:
      oprot.writeFieldBegin('inputColumns', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.inputColumns))
      for iter121 in self.inputColumns:
        oprot.writeString(iter121)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.outputColumns is not None:
      oprot.writeFieldBegin('outputColumns', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.outputColumns))
      for iter122 in self.outputColumns:
        oprot.writeString(iter122)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 6)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.oldDataFrame)
    value = (value * 31) ^ hash(self.newDataFrame)
    value = (value * 31) ^ hash(self.transformer)
    value = (value * 31) ^ hash(self.inputColumns)
    value = (value * 31) ^ hash(self.outputColumns)
    value = (value * 31) ^ hash(self.experimentRunId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TransformEventResponse:
  """
  Attributes:
   - oldDataFrameId
   - newDataFrameId
   - transformerId
   - eventId
   - filepath
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'oldDataFrameId', None, None, ), # 1
    (2, TType.I32, 'newDataFrameId', None, None, ), # 2
    (3, TType.I32, 'transformerId', None, None, ), # 3
    (4, TType.I32, 'eventId', None, None, ), # 4
    (5, TType.STRING, 'filepath', None, None, ), # 5
  )

  def __init__(self, oldDataFrameId=None, newDataFrameId=None, transformerId=None, eventId=None, filepath=None,):
    self.oldDataFrameId = oldDataFrameId
    self.newDataFrameId = newDataFrameId
    self.transformerId = transformerId
    self.eventId = eventId
    self.filepath = filepath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.oldDataFrameId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.newDataFrameId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.transformerId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.filepath = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TransformEventResponse')
    if self.oldDataFrameId is not None:
      oprot.writeFieldBegin('oldDataFrameId', TType.I32, 1)
      oprot.writeI32(self.oldDataFrameId)
      oprot.writeFieldEnd()
    if self.newDataFrameId is not None:
      oprot.writeFieldBegin('newDataFrameId', TType.I32, 2)
      oprot.writeI32(self.newDataFrameId)
      oprot.writeFieldEnd()
    if self.transformerId is not None:
      oprot.writeFieldBegin('transformerId', TType.I32, 3)
      oprot.writeI32(self.transformerId)
      oprot.writeFieldEnd()
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I32, 4)
      oprot.writeI32(self.eventId)
      oprot.writeFieldEnd()
    if self.filepath is not None:
      oprot.writeFieldBegin('filepath', TType.STRING, 5)
      oprot.writeString(self.filepath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.oldDataFrameId)
    value = (value * 31) ^ hash(self.newDataFrameId)
    value = (value * 31) ^ hash(self.transformerId)
    value = (value * 31) ^ hash(self.eventId)
    value = (value * 31) ^ hash(self.filepath)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RandomSplitEvent:
  """
  Attributes:
   - oldDataFrame
   - weights
   - seed
   - splitDataFrames
   - experimentRunId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'oldDataFrame', (DataFrame, DataFrame.thrift_spec), None, ), # 1
    (2, TType.LIST, 'weights', (TType.DOUBLE,None), None, ), # 2
    (3, TType.I64, 'seed', None, None, ), # 3
    (4, TType.LIST, 'splitDataFrames', (TType.STRUCT,(DataFrame, DataFrame.thrift_spec)), None, ), # 4
    (5, TType.I32, 'experimentRunId', None, None, ), # 5
  )

  def __init__(self, oldDataFrame=None, weights=None, seed=None, splitDataFrames=None, experimentRunId=None,):
    self.oldDataFrame = oldDataFrame
    self.weights = weights
    self.seed = seed
    self.splitDataFrames = splitDataFrames
    self.experimentRunId = experimentRunId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.oldDataFrame = DataFrame()
          self.oldDataFrame.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.weights = []
          (_etype126, _size123) = iprot.readListBegin()
          for _i127 in xrange(_size123):
            _elem128 = iprot.readDouble()
            self.weights.append(_elem128)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.seed = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.splitDataFrames = []
          (_etype132, _size129) = iprot.readListBegin()
          for _i133 in xrange(_size129):
            _elem134 = DataFrame()
            _elem134.read(iprot)
            self.splitDataFrames.append(_elem134)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RandomSplitEvent')
    if self.oldDataFrame is not None:
      oprot.writeFieldBegin('oldDataFrame', TType.STRUCT, 1)
      self.oldDataFrame.write(oprot)
      oprot.writeFieldEnd()
    if self.weights is not None:
      oprot.writeFieldBegin('weights', TType.LIST, 2)
      oprot.writeListBegin(TType.DOUBLE, len(self.weights))
      for iter135 in self.weights:
        oprot.writeDouble(iter135)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.seed is not None:
      oprot.writeFieldBegin('seed', TType.I64, 3)
      oprot.writeI64(self.seed)
      oprot.writeFieldEnd()
    if self.splitDataFrames is not None:
      oprot.writeFieldBegin('splitDataFrames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.splitDataFrames))
      for iter136 in self.splitDataFrames:
        iter136.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 5)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.oldDataFrame)
    value = (value * 31) ^ hash(self.weights)
    value = (value * 31) ^ hash(self.seed)
    value = (value * 31) ^ hash(self.splitDataFrames)
    value = (value * 31) ^ hash(self.experimentRunId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RandomSplitEventResponse:
  """
  Attributes:
   - oldDataFrameId
   - splitIds
   - splitEventId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'oldDataFrameId', None, None, ), # 1
    (2, TType.LIST, 'splitIds', (TType.I32,None), None, ), # 2
    (3, TType.I32, 'splitEventId', None, None, ), # 3
  )

  def __init__(self, oldDataFrameId=None, splitIds=None, splitEventId=None,):
    self.oldDataFrameId = oldDataFrameId
    self.splitIds = splitIds
    self.splitEventId = splitEventId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.oldDataFrameId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.splitIds = []
          (_etype140, _size137) = iprot.readListBegin()
          for _i141 in xrange(_size137):
            _elem142 = iprot.readI32()
            self.splitIds.append(_elem142)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.splitEventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RandomSplitEventResponse')
    if self.oldDataFrameId is not None:
      oprot.writeFieldBegin('oldDataFrameId', TType.I32, 1)
      oprot.writeI32(self.oldDataFrameId)
      oprot.writeFieldEnd()
    if self.splitIds is not None:
      oprot.writeFieldBegin('splitIds', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.splitIds))
      for iter143 in self.splitIds:
        oprot.writeI32(iter143)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.splitEventId is not None:
      oprot.writeFieldBegin('splitEventId', TType.I32, 3)
      oprot.writeI32(self.splitEventId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.oldDataFrameId)
    value = (value * 31) ^ hash(self.splitIds)
    value = (value * 31) ^ hash(self.splitEventId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrossValidationFold:
  """
  Attributes:
   - model
   - validationDf
   - trainingDf
   - score
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'model', (Transformer, Transformer.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'validationDf', (DataFrame, DataFrame.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'trainingDf', (DataFrame, DataFrame.thrift_spec), None, ), # 3
    (4, TType.DOUBLE, 'score', None, None, ), # 4
  )

  def __init__(self, model=None, validationDf=None, trainingDf=None, score=None,):
    self.model = model
    self.validationDf = validationDf
    self.trainingDf = trainingDf
    self.score = score

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.model = Transformer()
          self.model.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.validationDf = DataFrame()
          self.validationDf.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.trainingDf = DataFrame()
          self.trainingDf.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.score = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrossValidationFold')
    if self.model is not None:
      oprot.writeFieldBegin('model', TType.STRUCT, 1)
      self.model.write(oprot)
      oprot.writeFieldEnd()
    if self.validationDf is not None:
      oprot.writeFieldBegin('validationDf', TType.STRUCT, 2)
      self.validationDf.write(oprot)
      oprot.writeFieldEnd()
    if self.trainingDf is not None:
      oprot.writeFieldBegin('trainingDf', TType.STRUCT, 3)
      self.trainingDf.write(oprot)
      oprot.writeFieldEnd()
    if self.score is not None:
      oprot.writeFieldBegin('score', TType.DOUBLE, 4)
      oprot.writeDouble(self.score)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.model)
    value = (value * 31) ^ hash(self.validationDf)
    value = (value * 31) ^ hash(self.trainingDf)
    value = (value * 31) ^ hash(self.score)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrossValidationFoldResponse:
  """
  Attributes:
   - modelId
   - validationId
   - trainingId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId', None, None, ), # 1
    (2, TType.I32, 'validationId', None, None, ), # 2
    (3, TType.I32, 'trainingId', None, None, ), # 3
  )

  def __init__(self, modelId=None, validationId=None, trainingId=None,):
    self.modelId = modelId
    self.validationId = validationId
    self.trainingId = trainingId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.validationId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.trainingId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrossValidationFoldResponse')
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.I32, 1)
      oprot.writeI32(self.modelId)
      oprot.writeFieldEnd()
    if self.validationId is not None:
      oprot.writeFieldBegin('validationId', TType.I32, 2)
      oprot.writeI32(self.validationId)
      oprot.writeFieldEnd()
    if self.trainingId is not None:
      oprot.writeFieldBegin('trainingId', TType.I32, 3)
      oprot.writeI32(self.trainingId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId)
    value = (value * 31) ^ hash(self.validationId)
    value = (value * 31) ^ hash(self.trainingId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrossValidationEvent:
  """
  Attributes:
   - df
   - spec
   - seed
   - evaluator
   - labelColumns
   - predictionColumns
   - featureColumns
   - folds
   - experimentRunId
   - problemType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'df', (DataFrame, DataFrame.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'spec', (TransformerSpec, TransformerSpec.thrift_spec), None, ), # 2
    (3, TType.I64, 'seed', None, None, ), # 3
    (4, TType.STRING, 'evaluator', None, None, ), # 4
    (5, TType.LIST, 'labelColumns', (TType.STRING,None), None, ), # 5
    (6, TType.LIST, 'predictionColumns', (TType.STRING,None), None, ), # 6
    (7, TType.LIST, 'featureColumns', (TType.STRING,None), None, ), # 7
    (8, TType.LIST, 'folds', (TType.STRUCT,(CrossValidationFold, CrossValidationFold.thrift_spec)), None, ), # 8
    (9, TType.I32, 'experimentRunId', None, None, ), # 9
    (10, TType.I32, 'problemType', None,     0, ), # 10
  )

  def __init__(self, df=None, spec=None, seed=None, evaluator=None, labelColumns=None, predictionColumns=None, featureColumns=None, folds=None, experimentRunId=None, problemType=thrift_spec[10][4],):
    self.df = df
    self.spec = spec
    self.seed = seed
    self.evaluator = evaluator
    self.labelColumns = labelColumns
    self.predictionColumns = predictionColumns
    self.featureColumns = featureColumns
    self.folds = folds
    self.experimentRunId = experimentRunId
    self.problemType = problemType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.df = DataFrame()
          self.df.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.spec = TransformerSpec()
          self.spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.seed = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.evaluator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.labelColumns = []
          (_etype147, _size144) = iprot.readListBegin()
          for _i148 in xrange(_size144):
            _elem149 = iprot.readString()
            self.labelColumns.append(_elem149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.predictionColumns = []
          (_etype153, _size150) = iprot.readListBegin()
          for _i154 in xrange(_size150):
            _elem155 = iprot.readString()
            self.predictionColumns.append(_elem155)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.featureColumns = []
          (_etype159, _size156) = iprot.readListBegin()
          for _i160 in xrange(_size156):
            _elem161 = iprot.readString()
            self.featureColumns.append(_elem161)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.folds = []
          (_etype165, _size162) = iprot.readListBegin()
          for _i166 in xrange(_size162):
            _elem167 = CrossValidationFold()
            _elem167.read(iprot)
            self.folds.append(_elem167)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.problemType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrossValidationEvent')
    if self.df is not None:
      oprot.writeFieldBegin('df', TType.STRUCT, 1)
      self.df.write(oprot)
      oprot.writeFieldEnd()
    if self.spec is not None:
      oprot.writeFieldBegin('spec', TType.STRUCT, 2)
      self.spec.write(oprot)
      oprot.writeFieldEnd()
    if self.seed is not None:
      oprot.writeFieldBegin('seed', TType.I64, 3)
      oprot.writeI64(self.seed)
      oprot.writeFieldEnd()
    if self.evaluator is not None:
      oprot.writeFieldBegin('evaluator', TType.STRING, 4)
      oprot.writeString(self.evaluator)
      oprot.writeFieldEnd()
    if self.labelColumns is not None:
      oprot.writeFieldBegin('labelColumns', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.labelColumns))
      for iter168 in self.labelColumns:
        oprot.writeString(iter168)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.predictionColumns is not None:
      oprot.writeFieldBegin('predictionColumns', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.predictionColumns))
      for iter169 in self.predictionColumns:
        oprot.writeString(iter169)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.featureColumns is not None:
      oprot.writeFieldBegin('featureColumns', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.featureColumns))
      for iter170 in self.featureColumns:
        oprot.writeString(iter170)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.folds is not None:
      oprot.writeFieldBegin('folds', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.folds))
      for iter171 in self.folds:
        iter171.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 9)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    if self.problemType is not None:
      oprot.writeFieldBegin('problemType', TType.I32, 10)
      oprot.writeI32(self.problemType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.df)
    value = (value * 31) ^ hash(self.spec)
    value = (value * 31) ^ hash(self.seed)
    value = (value * 31) ^ hash(self.evaluator)
    value = (value * 31) ^ hash(self.labelColumns)
    value = (value * 31) ^ hash(self.predictionColumns)
    value = (value * 31) ^ hash(self.featureColumns)
    value = (value * 31) ^ hash(self.folds)
    value = (value * 31) ^ hash(self.experimentRunId)
    value = (value * 31) ^ hash(self.problemType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CrossValidationEventResponse:
  """
  Attributes:
   - dfId
   - specId
   - eventId
   - foldResponses
   - crossValidationEventId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dfId', None, None, ), # 1
    (2, TType.I32, 'specId', None, None, ), # 2
    (3, TType.I32, 'eventId', None, None, ), # 3
    (4, TType.LIST, 'foldResponses', (TType.STRUCT,(CrossValidationFoldResponse, CrossValidationFoldResponse.thrift_spec)), None, ), # 4
    (5, TType.I32, 'crossValidationEventId', None, None, ), # 5
  )

  def __init__(self, dfId=None, specId=None, eventId=None, foldResponses=None, crossValidationEventId=None,):
    self.dfId = dfId
    self.specId = specId
    self.eventId = eventId
    self.foldResponses = foldResponses
    self.crossValidationEventId = crossValidationEventId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dfId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.specId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.eventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.foldResponses = []
          (_etype175, _size172) = iprot.readListBegin()
          for _i176 in xrange(_size172):
            _elem177 = CrossValidationFoldResponse()
            _elem177.read(iprot)
            self.foldResponses.append(_elem177)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.crossValidationEventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CrossValidationEventResponse')
    if self.dfId is not None:
      oprot.writeFieldBegin('dfId', TType.I32, 1)
      oprot.writeI32(self.dfId)
      oprot.writeFieldEnd()
    if self.specId is not None:
      oprot.writeFieldBegin('specId', TType.I32, 2)
      oprot.writeI32(self.specId)
      oprot.writeFieldEnd()
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I32, 3)
      oprot.writeI32(self.eventId)
      oprot.writeFieldEnd()
    if self.foldResponses is not None:
      oprot.writeFieldBegin('foldResponses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.foldResponses))
      for iter178 in self.foldResponses:
        iter178.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.crossValidationEventId is not None:
      oprot.writeFieldBegin('crossValidationEventId', TType.I32, 5)
      oprot.writeI32(self.crossValidationEventId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dfId)
    value = (value * 31) ^ hash(self.specId)
    value = (value * 31) ^ hash(self.eventId)
    value = (value * 31) ^ hash(self.foldResponses)
    value = (value * 31) ^ hash(self.crossValidationEventId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GridSearchCrossValidationEvent:
  """
  Attributes:
   - numFolds
   - bestFit
   - crossValidations
   - experimentRunId
   - problemType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'numFolds', None, None, ), # 1
    (2, TType.STRUCT, 'bestFit', (FitEvent, FitEvent.thrift_spec), None, ), # 2
    (3, TType.LIST, 'crossValidations', (TType.STRUCT,(CrossValidationEvent, CrossValidationEvent.thrift_spec)), None, ), # 3
    (4, TType.I32, 'experimentRunId', None, None, ), # 4
    (5, TType.I32, 'problemType', None,     0, ), # 5
  )

  def __init__(self, numFolds=None, bestFit=None, crossValidations=None, experimentRunId=None, problemType=thrift_spec[5][4],):
    self.numFolds = numFolds
    self.bestFit = bestFit
    self.crossValidations = crossValidations
    self.experimentRunId = experimentRunId
    self.problemType = problemType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.numFolds = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.bestFit = FitEvent()
          self.bestFit.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.crossValidations = []
          (_etype182, _size179) = iprot.readListBegin()
          for _i183 in xrange(_size179):
            _elem184 = CrossValidationEvent()
            _elem184.read(iprot)
            self.crossValidations.append(_elem184)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.problemType = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GridSearchCrossValidationEvent')
    if self.numFolds is not None:
      oprot.writeFieldBegin('numFolds', TType.I32, 1)
      oprot.writeI32(self.numFolds)
      oprot.writeFieldEnd()
    if self.bestFit is not None:
      oprot.writeFieldBegin('bestFit', TType.STRUCT, 2)
      self.bestFit.write(oprot)
      oprot.writeFieldEnd()
    if self.crossValidations is not None:
      oprot.writeFieldBegin('crossValidations', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.crossValidations))
      for iter185 in self.crossValidations:
        iter185.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 4)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    if self.problemType is not None:
      oprot.writeFieldBegin('problemType', TType.I32, 5)
      oprot.writeI32(self.problemType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.numFolds)
    value = (value * 31) ^ hash(self.bestFit)
    value = (value * 31) ^ hash(self.crossValidations)
    value = (value * 31) ^ hash(self.experimentRunId)
    value = (value * 31) ^ hash(self.problemType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GridSearchCrossValidationEventResponse:
  """
  Attributes:
   - gscveId
   - eventId
   - fitEventResponse
   - crossValidationEventResponses
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gscveId', None, None, ), # 1
    (2, TType.I32, 'eventId', None, None, ), # 2
    (3, TType.STRUCT, 'fitEventResponse', (FitEventResponse, FitEventResponse.thrift_spec), None, ), # 3
    (4, TType.LIST, 'crossValidationEventResponses', (TType.STRUCT,(CrossValidationEventResponse, CrossValidationEventResponse.thrift_spec)), None, ), # 4
  )

  def __init__(self, gscveId=None, eventId=None, fitEventResponse=None, crossValidationEventResponses=None,):
    self.gscveId = gscveId
    self.eventId = eventId
    self.fitEventResponse = fitEventResponse
    self.crossValidationEventResponses = crossValidationEventResponses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gscveId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.eventId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.fitEventResponse = FitEventResponse()
          self.fitEventResponse.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.crossValidationEventResponses = []
          (_etype189, _size186) = iprot.readListBegin()
          for _i190 in xrange(_size186):
            _elem191 = CrossValidationEventResponse()
            _elem191.read(iprot)
            self.crossValidationEventResponses.append(_elem191)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GridSearchCrossValidationEventResponse')
    if self.gscveId is not None:
      oprot.writeFieldBegin('gscveId', TType.I32, 1)
      oprot.writeI32(self.gscveId)
      oprot.writeFieldEnd()
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.I32, 2)
      oprot.writeI32(self.eventId)
      oprot.writeFieldEnd()
    if self.fitEventResponse is not None:
      oprot.writeFieldBegin('fitEventResponse', TType.STRUCT, 3)
      self.fitEventResponse.write(oprot)
      oprot.writeFieldEnd()
    if self.crossValidationEventResponses is not None:
      oprot.writeFieldBegin('crossValidationEventResponses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.crossValidationEventResponses))
      for iter192 in self.crossValidationEventResponses:
        iter192.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.gscveId)
    value = (value * 31) ^ hash(self.eventId)
    value = (value * 31) ^ hash(self.fitEventResponse)
    value = (value * 31) ^ hash(self.crossValidationEventResponses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PipelineTransformStage:
  """
  Attributes:
   - stageNumber
   - te
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'stageNumber', None, None, ), # 1
    (2, TType.STRUCT, 'te', (TransformEvent, TransformEvent.thrift_spec), None, ), # 2
  )

  def __init__(self, stageNumber=None, te=None,):
    self.stageNumber = stageNumber
    self.te = te

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.stageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.te = TransformEvent()
          self.te.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PipelineTransformStage')
    if self.stageNumber is not None:
      oprot.writeFieldBegin('stageNumber', TType.I32, 1)
      oprot.writeI32(self.stageNumber)
      oprot.writeFieldEnd()
    if self.te is not None:
      oprot.writeFieldBegin('te', TType.STRUCT, 2)
      self.te.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stageNumber)
    value = (value * 31) ^ hash(self.te)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PipelineFitStage:
  """
  Attributes:
   - stageNumber
   - fe
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'stageNumber', None, None, ), # 1
    (2, TType.STRUCT, 'fe', (FitEvent, FitEvent.thrift_spec), None, ), # 2
  )

  def __init__(self, stageNumber=None, fe=None,):
    self.stageNumber = stageNumber
    self.fe = fe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.stageNumber = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.fe = FitEvent()
          self.fe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PipelineFitStage')
    if self.stageNumber is not None:
      oprot.writeFieldBegin('stageNumber', TType.I32, 1)
      oprot.writeI32(self.stageNumber)
      oprot.writeFieldEnd()
    if self.fe is not None:
      oprot.writeFieldBegin('fe', TType.STRUCT, 2)
      self.fe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stageNumber)
    value = (value * 31) ^ hash(self.fe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PipelineEvent:
  """
  Attributes:
   - pipelineFit
   - transformStages
   - fitStages
   - experimentRunId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pipelineFit', (FitEvent, FitEvent.thrift_spec), None, ), # 1
    (2, TType.LIST, 'transformStages', (TType.STRUCT,(PipelineTransformStage, PipelineTransformStage.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'fitStages', (TType.STRUCT,(PipelineFitStage, PipelineFitStage.thrift_spec)), None, ), # 3
    (4, TType.I32, 'experimentRunId', None, None, ), # 4
  )

  def __init__(self, pipelineFit=None, transformStages=None, fitStages=None, experimentRunId=None,):
    self.pipelineFit = pipelineFit
    self.transformStages = transformStages
    self.fitStages = fitStages
    self.experimentRunId = experimentRunId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pipelineFit = FitEvent()
          self.pipelineFit.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.transformStages = []
          (_etype196, _size193) = iprot.readListBegin()
          for _i197 in xrange(_size193):
            _elem198 = PipelineTransformStage()
            _elem198.read(iprot)
            self.transformStages.append(_elem198)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fitStages = []
          (_etype202, _size199) = iprot.readListBegin()
          for _i203 in xrange(_size199):
            _elem204 = PipelineFitStage()
            _elem204.read(iprot)
            self.fitStages.append(_elem204)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PipelineEvent')
    if self.pipelineFit is not None:
      oprot.writeFieldBegin('pipelineFit', TType.STRUCT, 1)
      self.pipelineFit.write(oprot)
      oprot.writeFieldEnd()
    if self.transformStages is not None:
      oprot.writeFieldBegin('transformStages', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.transformStages))
      for iter205 in self.transformStages:
        iter205.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fitStages is not None:
      oprot.writeFieldBegin('fitStages', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.fitStages))
      for iter206 in self.fitStages:
        iter206.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 4)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pipelineFit)
    value = (value * 31) ^ hash(self.transformStages)
    value = (value * 31) ^ hash(self.fitStages)
    value = (value * 31) ^ hash(self.experimentRunId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PipelineEventResponse:
  """
  Attributes:
   - pipelineFitResponse
   - transformStagesResponses
   - fitStagesResponses
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pipelineFitResponse', (FitEventResponse, FitEventResponse.thrift_spec), None, ), # 1
    (2, TType.LIST, 'transformStagesResponses', (TType.STRUCT,(TransformEventResponse, TransformEventResponse.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'fitStagesResponses', (TType.STRUCT,(FitEventResponse, FitEventResponse.thrift_spec)), None, ), # 3
  )

  def __init__(self, pipelineFitResponse=None, transformStagesResponses=None, fitStagesResponses=None,):
    self.pipelineFitResponse = pipelineFitResponse
    self.transformStagesResponses = transformStagesResponses
    self.fitStagesResponses = fitStagesResponses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pipelineFitResponse = FitEventResponse()
          self.pipelineFitResponse.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.transformStagesResponses = []
          (_etype210, _size207) = iprot.readListBegin()
          for _i211 in xrange(_size207):
            _elem212 = TransformEventResponse()
            _elem212.read(iprot)
            self.transformStagesResponses.append(_elem212)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fitStagesResponses = []
          (_etype216, _size213) = iprot.readListBegin()
          for _i217 in xrange(_size213):
            _elem218 = FitEventResponse()
            _elem218.read(iprot)
            self.fitStagesResponses.append(_elem218)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PipelineEventResponse')
    if self.pipelineFitResponse is not None:
      oprot.writeFieldBegin('pipelineFitResponse', TType.STRUCT, 1)
      self.pipelineFitResponse.write(oprot)
      oprot.writeFieldEnd()
    if self.transformStagesResponses is not None:
      oprot.writeFieldBegin('transformStagesResponses', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.transformStagesResponses))
      for iter219 in self.transformStagesResponses:
        iter219.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fitStagesResponses is not None:
      oprot.writeFieldBegin('fitStagesResponses', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.fitStagesResponses))
      for iter220 in self.fitStagesResponses:
        iter220.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pipelineFitResponse)
    value = (value * 31) ^ hash(self.transformStagesResponses)
    value = (value * 31) ^ hash(self.fitStagesResponses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AnnotationFragment:
  """
  Attributes:
   - type
   - df
   - spec
   - transformer
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
    (2, TType.STRUCT, 'df', (DataFrame, DataFrame.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'spec', (TransformerSpec, TransformerSpec.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transformer', (Transformer, Transformer.thrift_spec), None, ), # 4
    (5, TType.STRING, 'message', None, None, ), # 5
  )

  def __init__(self, type=None, df=None, spec=None, transformer=None, message=None,):
    self.type = type
    self.df = df
    self.spec = spec
    self.transformer = transformer
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.df = DataFrame()
          self.df.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.spec = TransformerSpec()
          self.spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transformer = Transformer()
          self.transformer.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AnnotationFragment')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.df is not None:
      oprot.writeFieldBegin('df', TType.STRUCT, 2)
      self.df.write(oprot)
      oprot.writeFieldEnd()
    if self.spec is not None:
      oprot.writeFieldBegin('spec', TType.STRUCT, 3)
      self.spec.write(oprot)
      oprot.writeFieldEnd()
    if self.transformer is not None:
      oprot.writeFieldBegin('transformer', TType.STRUCT, 4)
      self.transformer.write(oprot)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 5)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.df)
    value = (value * 31) ^ hash(self.spec)
    value = (value * 31) ^ hash(self.transformer)
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AnnotationFragmentResponse:
  """
  Attributes:
   - type
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
    (2, TType.I32, 'id', None, None, ), # 2
  )

  def __init__(self, type=None, id=None,):
    self.type = type
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AnnotationFragmentResponse')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 2)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AnnotationEvent:
  """
  Attributes:
   - fragments
   - experimentRunId
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fragments', (TType.STRUCT,(AnnotationFragment, AnnotationFragment.thrift_spec)), None, ), # 1
    (2, TType.I32, 'experimentRunId', None, None, ), # 2
  )

  def __init__(self, fragments=None, experimentRunId=None,):
    self.fragments = fragments
    self.experimentRunId = experimentRunId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fragments = []
          (_etype224, _size221) = iprot.readListBegin()
          for _i225 in xrange(_size221):
            _elem226 = AnnotationFragment()
            _elem226.read(iprot)
            self.fragments.append(_elem226)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.experimentRunId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AnnotationEvent')
    if self.fragments is not None:
      oprot.writeFieldBegin('fragments', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fragments))
      for iter227 in self.fragments:
        iter227.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentRunId is not None:
      oprot.writeFieldBegin('experimentRunId', TType.I32, 2)
      oprot.writeI32(self.experimentRunId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fragments)
    value = (value * 31) ^ hash(self.experimentRunId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AnnotationEventResponse:
  """
  Attributes:
   - annotationId
   - fragmentResponses
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'annotationId', None, None, ), # 1
    (2, TType.LIST, 'fragmentResponses', (TType.STRUCT,(AnnotationFragmentResponse, AnnotationFragmentResponse.thrift_spec)), None, ), # 2
  )

  def __init__(self, annotationId=None, fragmentResponses=None,):
    self.annotationId = annotationId
    self.fragmentResponses = fragmentResponses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.annotationId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.fragmentResponses = []
          (_etype231, _size228) = iprot.readListBegin()
          for _i232 in xrange(_size228):
            _elem233 = AnnotationFragmentResponse()
            _elem233.read(iprot)
            self.fragmentResponses.append(_elem233)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AnnotationEventResponse')
    if self.annotationId is not None:
      oprot.writeFieldBegin('annotationId', TType.I32, 1)
      oprot.writeI32(self.annotationId)
      oprot.writeFieldEnd()
    if self.fragmentResponses is not None:
      oprot.writeFieldBegin('fragmentResponses', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.fragmentResponses))
      for iter234 in self.fragmentResponses:
        iter234.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.annotationId)
    value = (value * 31) ^ hash(self.fragmentResponses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataFrameAncestry:
  """
  Attributes:
   - ancestors
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'ancestors', (TType.STRUCT,(DataFrame, DataFrame.thrift_spec)), None, ), # 1
  )

  def __init__(self, ancestors=None,):
    self.ancestors = ancestors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.ancestors = []
          (_etype238, _size235) = iprot.readListBegin()
          for _i239 in xrange(_size235):
            _elem240 = DataFrame()
            _elem240.read(iprot)
            self.ancestors.append(_elem240)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataFrameAncestry')
    if self.ancestors is not None:
      oprot.writeFieldBegin('ancestors', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.ancestors))
      for iter241 in self.ancestors:
        iter241.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ancestors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CommonAncestor:
  """
  Attributes:
   - ancestor
   - chainIndexModel1
   - chainIndexModel2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ancestor', (DataFrame, DataFrame.thrift_spec), None, ), # 1
    (2, TType.I32, 'chainIndexModel1', None, None, ), # 2
    (3, TType.I32, 'chainIndexModel2', None, None, ), # 3
  )

  def __init__(self, ancestor=None, chainIndexModel1=None, chainIndexModel2=None,):
    self.ancestor = ancestor
    self.chainIndexModel1 = chainIndexModel1
    self.chainIndexModel2 = chainIndexModel2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ancestor = DataFrame()
          self.ancestor.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.chainIndexModel1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.chainIndexModel2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CommonAncestor')
    if self.ancestor is not None:
      oprot.writeFieldBegin('ancestor', TType.STRUCT, 1)
      self.ancestor.write(oprot)
      oprot.writeFieldEnd()
    if self.chainIndexModel1 is not None:
      oprot.writeFieldBegin('chainIndexModel1', TType.I32, 2)
      oprot.writeI32(self.chainIndexModel1)
      oprot.writeFieldEnd()
    if self.chainIndexModel2 is not None:
      oprot.writeFieldBegin('chainIndexModel2', TType.I32, 3)
      oprot.writeI32(self.chainIndexModel2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ancestor)
    value = (value * 31) ^ hash(self.chainIndexModel1)
    value = (value * 31) ^ hash(self.chainIndexModel2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StringPair:
  """
  Attributes:
   - first
   - second
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'first', None, None, ), # 1
    (2, TType.STRING, 'second', None, None, ), # 2
  )

  def __init__(self, first=None, second=None,):
    self.first = first
    self.second = second

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.first = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.second = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StringPair')
    if self.first is not None:
      oprot.writeFieldBegin('first', TType.STRING, 1)
      oprot.writeString(self.first)
      oprot.writeFieldEnd()
    if self.second is not None:
      oprot.writeFieldBegin('second', TType.STRING, 2)
      oprot.writeString(self.second)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.first)
    value = (value * 31) ^ hash(self.second)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CompareHyperParametersResponse:
  """
  Attributes:
   - model1OnlyHyperparams
   - model2OnlyHyperparams
   - sharedHyperparams
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'model1OnlyHyperparams', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.MAP, 'model2OnlyHyperparams', (TType.STRING,None,TType.STRING,None), None, ), # 2
    (3, TType.MAP, 'sharedHyperparams', (TType.STRING,None,TType.STRUCT,(StringPair, StringPair.thrift_spec)), None, ), # 3
  )

  def __init__(self, model1OnlyHyperparams=None, model2OnlyHyperparams=None, sharedHyperparams=None,):
    self.model1OnlyHyperparams = model1OnlyHyperparams
    self.model2OnlyHyperparams = model2OnlyHyperparams
    self.sharedHyperparams = sharedHyperparams

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.model1OnlyHyperparams = {}
          (_ktype243, _vtype244, _size242 ) = iprot.readMapBegin()
          for _i246 in xrange(_size242):
            _key247 = iprot.readString()
            _val248 = iprot.readString()
            self.model1OnlyHyperparams[_key247] = _val248
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.model2OnlyHyperparams = {}
          (_ktype250, _vtype251, _size249 ) = iprot.readMapBegin()
          for _i253 in xrange(_size249):
            _key254 = iprot.readString()
            _val255 = iprot.readString()
            self.model2OnlyHyperparams[_key254] = _val255
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.sharedHyperparams = {}
          (_ktype257, _vtype258, _size256 ) = iprot.readMapBegin()
          for _i260 in xrange(_size256):
            _key261 = iprot.readString()
            _val262 = StringPair()
            _val262.read(iprot)
            self.sharedHyperparams[_key261] = _val262
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CompareHyperParametersResponse')
    if self.model1OnlyHyperparams is not None:
      oprot.writeFieldBegin('model1OnlyHyperparams', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.model1OnlyHyperparams))
      for kiter263,viter264 in self.model1OnlyHyperparams.items():
        oprot.writeString(kiter263)
        oprot.writeString(viter264)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.model2OnlyHyperparams is not None:
      oprot.writeFieldBegin('model2OnlyHyperparams', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.model2OnlyHyperparams))
      for kiter265,viter266 in self.model2OnlyHyperparams.items():
        oprot.writeString(kiter265)
        oprot.writeString(viter266)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.sharedHyperparams is not None:
      oprot.writeFieldBegin('sharedHyperparams', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.sharedHyperparams))
      for kiter267,viter268 in self.sharedHyperparams.items():
        oprot.writeString(kiter267)
        viter268.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.model1OnlyHyperparams)
    value = (value * 31) ^ hash(self.model2OnlyHyperparams)
    value = (value * 31) ^ hash(self.sharedHyperparams)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CompareFeaturesResponse:
  """
  Attributes:
   - model1OnlyFeatures
   - model2OnlyFeatures
   - commonFeatures
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'model1OnlyFeatures', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'model2OnlyFeatures', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'commonFeatures', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, model1OnlyFeatures=None, model2OnlyFeatures=None, commonFeatures=None,):
    self.model1OnlyFeatures = model1OnlyFeatures
    self.model2OnlyFeatures = model2OnlyFeatures
    self.commonFeatures = commonFeatures

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.model1OnlyFeatures = []
          (_etype272, _size269) = iprot.readListBegin()
          for _i273 in xrange(_size269):
            _elem274 = iprot.readString()
            self.model1OnlyFeatures.append(_elem274)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.model2OnlyFeatures = []
          (_etype278, _size275) = iprot.readListBegin()
          for _i279 in xrange(_size275):
            _elem280 = iprot.readString()
            self.model2OnlyFeatures.append(_elem280)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.commonFeatures = []
          (_etype284, _size281) = iprot.readListBegin()
          for _i285 in xrange(_size281):
            _elem286 = iprot.readString()
            self.commonFeatures.append(_elem286)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CompareFeaturesResponse')
    if self.model1OnlyFeatures is not None:
      oprot.writeFieldBegin('model1OnlyFeatures', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.model1OnlyFeatures))
      for iter287 in self.model1OnlyFeatures:
        oprot.writeString(iter287)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.model2OnlyFeatures is not None:
      oprot.writeFieldBegin('model2OnlyFeatures', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.model2OnlyFeatures))
      for iter288 in self.model2OnlyFeatures:
        oprot.writeString(iter288)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.commonFeatures is not None:
      oprot.writeFieldBegin('commonFeatures', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.commonFeatures))
      for iter289 in self.commonFeatures:
        oprot.writeString(iter289)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.model1OnlyFeatures)
    value = (value * 31) ^ hash(self.model2OnlyFeatures)
    value = (value * 31) ^ hash(self.commonFeatures)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class FeatureImportanceComparison:
  """
  Attributes:
   - featureName
   - percentileRankInModel1
   - percentileRankInModel2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'featureName', None, None, ), # 1
    (2, TType.DOUBLE, 'percentileRankInModel1', None, None, ), # 2
    (3, TType.DOUBLE, 'percentileRankInModel2', None, None, ), # 3
  )

  def __init__(self, featureName=None, percentileRankInModel1=None, percentileRankInModel2=None,):
    self.featureName = featureName
    self.percentileRankInModel1 = percentileRankInModel1
    self.percentileRankInModel2 = percentileRankInModel2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.featureName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.percentileRankInModel1 = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.percentileRankInModel2 = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('FeatureImportanceComparison')
    if self.featureName is not None:
      oprot.writeFieldBegin('featureName', TType.STRING, 1)
      oprot.writeString(self.featureName)
      oprot.writeFieldEnd()
    if self.percentileRankInModel1 is not None:
      oprot.writeFieldBegin('percentileRankInModel1', TType.DOUBLE, 2)
      oprot.writeDouble(self.percentileRankInModel1)
      oprot.writeFieldEnd()
    if self.percentileRankInModel2 is not None:
      oprot.writeFieldBegin('percentileRankInModel2', TType.DOUBLE, 3)
      oprot.writeDouble(self.percentileRankInModel2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.featureName)
    value = (value * 31) ^ hash(self.percentileRankInModel1)
    value = (value * 31) ^ hash(self.percentileRankInModel2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfidenceInterval:
  """
  Attributes:
   - featureIndex
   - low
   - high
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'featureIndex', None, None, ), # 1
    (2, TType.DOUBLE, 'low', None, None, ), # 2
    (3, TType.DOUBLE, 'high', None, None, ), # 3
  )

  def __init__(self, featureIndex=None, low=None, high=None,):
    self.featureIndex = featureIndex
    self.low = low
    self.high = high

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.featureIndex = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.low = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.high = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfidenceInterval')
    if self.featureIndex is not None:
      oprot.writeFieldBegin('featureIndex', TType.I32, 1)
      oprot.writeI32(self.featureIndex)
      oprot.writeFieldEnd()
    if self.low is not None:
      oprot.writeFieldBegin('low', TType.DOUBLE, 2)
      oprot.writeDouble(self.low)
      oprot.writeFieldEnd()
    if self.high is not None:
      oprot.writeFieldBegin('high', TType.DOUBLE, 3)
      oprot.writeDouble(self.high)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.featureIndex)
    value = (value * 31) ^ hash(self.low)
    value = (value * 31) ^ hash(self.high)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProjectExperimentsAndRuns:
  """
  Attributes:
   - projId
   - experiments
   - experimentRuns
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'projId', None, None, ), # 1
    (2, TType.LIST, 'experiments', (TType.STRUCT,(Experiment, Experiment.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'experimentRuns', (TType.STRUCT,(ExperimentRun, ExperimentRun.thrift_spec)), None, ), # 3
  )

  def __init__(self, projId=None, experiments=None, experimentRuns=None,):
    self.projId = projId
    self.experiments = experiments
    self.experimentRuns = experimentRuns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.projId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.experiments = []
          (_etype293, _size290) = iprot.readListBegin()
          for _i294 in xrange(_size290):
            _elem295 = Experiment()
            _elem295.read(iprot)
            self.experiments.append(_elem295)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.experimentRuns = []
          (_etype299, _size296) = iprot.readListBegin()
          for _i300 in xrange(_size296):
            _elem301 = ExperimentRun()
            _elem301.read(iprot)
            self.experimentRuns.append(_elem301)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProjectExperimentsAndRuns')
    if self.projId is not None:
      oprot.writeFieldBegin('projId', TType.I32, 1)
      oprot.writeI32(self.projId)
      oprot.writeFieldEnd()
    if self.experiments is not None:
      oprot.writeFieldBegin('experiments', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.experiments))
      for iter302 in self.experiments:
        iter302.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentRuns is not None:
      oprot.writeFieldBegin('experimentRuns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.experimentRuns))
      for iter303 in self.experimentRuns:
        iter303.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.projId)
    value = (value * 31) ^ hash(self.experiments)
    value = (value * 31) ^ hash(self.experimentRuns)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProjectOverviewResponse:
  """
  Attributes:
   - project
   - numExperiments
   - numExperimentRuns
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'project', (Project, Project.thrift_spec), None, ), # 1
    (2, TType.I32, 'numExperiments', None, None, ), # 2
    (3, TType.I32, 'numExperimentRuns', None, None, ), # 3
  )

  def __init__(self, project=None, numExperiments=None, numExperimentRuns=None,):
    self.project = project
    self.numExperiments = numExperiments
    self.numExperimentRuns = numExperimentRuns

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.project = Project()
          self.project.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.numExperiments = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.numExperimentRuns = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProjectOverviewResponse')
    if self.project is not None:
      oprot.writeFieldBegin('project', TType.STRUCT, 1)
      self.project.write(oprot)
      oprot.writeFieldEnd()
    if self.numExperiments is not None:
      oprot.writeFieldBegin('numExperiments', TType.I32, 2)
      oprot.writeI32(self.numExperiments)
      oprot.writeFieldEnd()
    if self.numExperimentRuns is not None:
      oprot.writeFieldBegin('numExperimentRuns', TType.I32, 3)
      oprot.writeI32(self.numExperimentRuns)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.project)
    value = (value * 31) ^ hash(self.numExperiments)
    value = (value * 31) ^ hash(self.numExperimentRuns)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExperimentRunDetailsResponse:
  """
  Attributes:
   - project
   - experiment
   - experimentRun
   - modelResponses
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'project', (Project, Project.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'experiment', (Experiment, Experiment.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'experimentRun', (ExperimentRun, ExperimentRun.thrift_spec), None, ), # 3
    (4, TType.LIST, 'modelResponses', (TType.STRUCT,(ModelResponse, ModelResponse.thrift_spec)), None, ), # 4
  )

  def __init__(self, project=None, experiment=None, experimentRun=None, modelResponses=None,):
    self.project = project
    self.experiment = experiment
    self.experimentRun = experimentRun
    self.modelResponses = modelResponses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.project = Project()
          self.project.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.experiment = Experiment()
          self.experiment.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.experimentRun = ExperimentRun()
          self.experimentRun.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.modelResponses = []
          (_etype307, _size304) = iprot.readListBegin()
          for _i308 in xrange(_size304):
            _elem309 = ModelResponse()
            _elem309.read(iprot)
            self.modelResponses.append(_elem309)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentRunDetailsResponse')
    if self.project is not None:
      oprot.writeFieldBegin('project', TType.STRUCT, 1)
      self.project.write(oprot)
      oprot.writeFieldEnd()
    if self.experiment is not None:
      oprot.writeFieldBegin('experiment', TType.STRUCT, 2)
      self.experiment.write(oprot)
      oprot.writeFieldEnd()
    if self.experimentRun is not None:
      oprot.writeFieldBegin('experimentRun', TType.STRUCT, 3)
      self.experimentRun.write(oprot)
      oprot.writeFieldEnd()
    if self.modelResponses is not None:
      oprot.writeFieldBegin('modelResponses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.modelResponses))
      for iter310 in self.modelResponses:
        iter310.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.project)
    value = (value * 31) ^ hash(self.experiment)
    value = (value * 31) ^ hash(self.experimentRun)
    value = (value * 31) ^ hash(self.modelResponses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResourceNotFoundException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceNotFoundException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidFieldException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidFieldException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BadRequestException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BadRequestException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IllegalOperationException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IllegalOperationException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ServerLogicException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ServerLogicException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidExperimentRunException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidExperimentRunException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
