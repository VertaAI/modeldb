#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def testConnection(self):
    pass

  def pathForTransformer(self, transformerId):
    """
    Parameters:
     - transformerId
    """
    pass

  def storeFitEvent(self, fe):
    """
    Parameters:
     - fe
    """
    pass

  def storeMetricEvent(self, me):
    """
    Parameters:
     - me
    """
    pass

  def storeTransformEvent(self, te):
    """
    Parameters:
     - te
    """
    pass

  def storeRandomSplitEvent(self, rse):
    """
    Parameters:
     - rse
    """
    pass

  def storePipelineEvent(self, pipelineEvent):
    """
    Parameters:
     - pipelineEvent
    """
    pass

  def storeCrossValidationEvent(self, cve):
    """
    Parameters:
     - cve
    """
    pass

  def storeGridSearchCrossValidationEvent(self, gscve):
    """
    Parameters:
     - gscve
    """
    pass

  def storeAnnotationEvent(self, ae):
    """
    Parameters:
     - ae
    """
    pass

  def storeProjectEvent(self, pr):
    """
    Parameters:
     - pr
    """
    pass

  def storeExperimentEvent(self, er):
    """
    Parameters:
     - er
    """
    pass

  def storeExperimentRunEvent(self, er):
    """
    Parameters:
     - er
    """
    pass

  def storeLinearModel(self, modelId, model):
    """
    Parameters:
     - modelId
     - model
    """
    pass

  def getDataFrameAncestry(self, dataFrameId):
    """
    Parameters:
     - dataFrameId
    """
    pass

  def getCommonAncestor(self, dfId1, dfId2):
    """
    Parameters:
     - dfId1
     - dfId2
    """
    pass

  def getCommonAncestorForModels(self, modelId1, modelId2):
    """
    Parameters:
     - modelId1
     - modelId2
    """
    pass

  def getTrainingRowsCount(self, modelId):
    """
    Parameters:
     - modelId
    """
    pass

  def getTrainingRowsCounts(self, modelIds):
    """
    Parameters:
     - modelIds
    """
    pass

  def compareHyperparameters(self, modelId1, modelId2):
    """
    Parameters:
     - modelId1
     - modelId2
    """
    pass

  def compareFeatures(self, modelId1, modelId2):
    """
    Parameters:
     - modelId1
     - modelId2
    """
    pass

  def groupByProblemType(self, modelIds):
    """
    Parameters:
     - modelIds
    """
    pass

  def similarModels(self, modelId, compMetrics, numModels):
    """
    Parameters:
     - modelId
     - compMetrics
     - numModels
    """
    pass

  def linearModelFeatureImportances(self, modelId):
    """
    Parameters:
     - modelId
    """
    pass

  def compareLinearModelFeatureImportances(self, model1Id, model2Id):
    """
    Parameters:
     - model1Id
     - model2Id
    """
    pass

  def iterationsUntilConvergence(self, modelIds, tolerance):
    """
    Parameters:
     - modelIds
     - tolerance
    """
    pass

  def rankModels(self, modelIds, metric):
    """
    Parameters:
     - modelIds
     - metric
    """
    pass

  def confidenceIntervals(self, modelId, sigLevel):
    """
    Parameters:
     - modelId
     - sigLevel
    """
    pass

  def modelsWithFeatures(self, featureNames):
    """
    Parameters:
     - featureNames
    """
    pass

  def modelsDerivedFromDataFrame(self, dfId):
    """
    Parameters:
     - dfId
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def testConnection(self):
    self.send_testConnection()
    return self.recv_testConnection()

  def send_testConnection(self):
    self._oprot.writeMessageBegin('testConnection', TMessageType.CALL, self._seqid)
    args = testConnection_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_testConnection(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testConnection_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testConnection failed: unknown result")

  def pathForTransformer(self, transformerId):
    """
    Parameters:
     - transformerId
    """
    self.send_pathForTransformer(transformerId)
    return self.recv_pathForTransformer()

  def send_pathForTransformer(self, transformerId):
    self._oprot.writeMessageBegin('pathForTransformer', TMessageType.CALL, self._seqid)
    args = pathForTransformer_args()
    args.transformerId = transformerId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pathForTransformer(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pathForTransformer_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    if result.efEx is not None:
      raise result.efEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pathForTransformer failed: unknown result")

  def storeFitEvent(self, fe):
    """
    Parameters:
     - fe
    """
    self.send_storeFitEvent(fe)
    return self.recv_storeFitEvent()

  def send_storeFitEvent(self, fe):
    self._oprot.writeMessageBegin('storeFitEvent', TMessageType.CALL, self._seqid)
    args = storeFitEvent_args()
    args.fe = fe
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeFitEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeFitEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ierEx is not None:
      raise result.ierEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeFitEvent failed: unknown result")

  def storeMetricEvent(self, me):
    """
    Parameters:
     - me
    """
    self.send_storeMetricEvent(me)
    return self.recv_storeMetricEvent()

  def send_storeMetricEvent(self, me):
    self._oprot.writeMessageBegin('storeMetricEvent', TMessageType.CALL, self._seqid)
    args = storeMetricEvent_args()
    args.me = me
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeMetricEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeMetricEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ierEx is not None:
      raise result.ierEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeMetricEvent failed: unknown result")

  def storeTransformEvent(self, te):
    """
    Parameters:
     - te
    """
    self.send_storeTransformEvent(te)
    return self.recv_storeTransformEvent()

  def send_storeTransformEvent(self, te):
    self._oprot.writeMessageBegin('storeTransformEvent', TMessageType.CALL, self._seqid)
    args = storeTransformEvent_args()
    args.te = te
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeTransformEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeTransformEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ierEx is not None:
      raise result.ierEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeTransformEvent failed: unknown result")

  def storeRandomSplitEvent(self, rse):
    """
    Parameters:
     - rse
    """
    self.send_storeRandomSplitEvent(rse)
    return self.recv_storeRandomSplitEvent()

  def send_storeRandomSplitEvent(self, rse):
    self._oprot.writeMessageBegin('storeRandomSplitEvent', TMessageType.CALL, self._seqid)
    args = storeRandomSplitEvent_args()
    args.rse = rse
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeRandomSplitEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeRandomSplitEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeRandomSplitEvent failed: unknown result")

  def storePipelineEvent(self, pipelineEvent):
    """
    Parameters:
     - pipelineEvent
    """
    self.send_storePipelineEvent(pipelineEvent)
    return self.recv_storePipelineEvent()

  def send_storePipelineEvent(self, pipelineEvent):
    self._oprot.writeMessageBegin('storePipelineEvent', TMessageType.CALL, self._seqid)
    args = storePipelineEvent_args()
    args.pipelineEvent = pipelineEvent
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storePipelineEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storePipelineEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storePipelineEvent failed: unknown result")

  def storeCrossValidationEvent(self, cve):
    """
    Parameters:
     - cve
    """
    self.send_storeCrossValidationEvent(cve)
    return self.recv_storeCrossValidationEvent()

  def send_storeCrossValidationEvent(self, cve):
    self._oprot.writeMessageBegin('storeCrossValidationEvent', TMessageType.CALL, self._seqid)
    args = storeCrossValidationEvent_args()
    args.cve = cve
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeCrossValidationEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeCrossValidationEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeCrossValidationEvent failed: unknown result")

  def storeGridSearchCrossValidationEvent(self, gscve):
    """
    Parameters:
     - gscve
    """
    self.send_storeGridSearchCrossValidationEvent(gscve)
    return self.recv_storeGridSearchCrossValidationEvent()

  def send_storeGridSearchCrossValidationEvent(self, gscve):
    self._oprot.writeMessageBegin('storeGridSearchCrossValidationEvent', TMessageType.CALL, self._seqid)
    args = storeGridSearchCrossValidationEvent_args()
    args.gscve = gscve
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeGridSearchCrossValidationEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeGridSearchCrossValidationEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeGridSearchCrossValidationEvent failed: unknown result")

  def storeAnnotationEvent(self, ae):
    """
    Parameters:
     - ae
    """
    self.send_storeAnnotationEvent(ae)
    return self.recv_storeAnnotationEvent()

  def send_storeAnnotationEvent(self, ae):
    self._oprot.writeMessageBegin('storeAnnotationEvent', TMessageType.CALL, self._seqid)
    args = storeAnnotationEvent_args()
    args.ae = ae
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeAnnotationEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeAnnotationEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeAnnotationEvent failed: unknown result")

  def storeProjectEvent(self, pr):
    """
    Parameters:
     - pr
    """
    self.send_storeProjectEvent(pr)
    return self.recv_storeProjectEvent()

  def send_storeProjectEvent(self, pr):
    self._oprot.writeMessageBegin('storeProjectEvent', TMessageType.CALL, self._seqid)
    args = storeProjectEvent_args()
    args.pr = pr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeProjectEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeProjectEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeProjectEvent failed: unknown result")

  def storeExperimentEvent(self, er):
    """
    Parameters:
     - er
    """
    self.send_storeExperimentEvent(er)
    return self.recv_storeExperimentEvent()

  def send_storeExperimentEvent(self, er):
    self._oprot.writeMessageBegin('storeExperimentEvent', TMessageType.CALL, self._seqid)
    args = storeExperimentEvent_args()
    args.er = er
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeExperimentEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeExperimentEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeExperimentEvent failed: unknown result")

  def storeExperimentRunEvent(self, er):
    """
    Parameters:
     - er
    """
    self.send_storeExperimentRunEvent(er)
    return self.recv_storeExperimentRunEvent()

  def send_storeExperimentRunEvent(self, er):
    self._oprot.writeMessageBegin('storeExperimentRunEvent', TMessageType.CALL, self._seqid)
    args = storeExperimentRunEvent_args()
    args.er = er
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeExperimentRunEvent(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeExperimentRunEvent_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeExperimentRunEvent failed: unknown result")

  def storeLinearModel(self, modelId, model):
    """
    Parameters:
     - modelId
     - model
    """
    self.send_storeLinearModel(modelId, model)
    return self.recv_storeLinearModel()

  def send_storeLinearModel(self, modelId, model):
    self._oprot.writeMessageBegin('storeLinearModel', TMessageType.CALL, self._seqid)
    args = storeLinearModel_args()
    args.modelId = modelId
    args.model = model
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeLinearModel(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = storeLinearModel_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "storeLinearModel failed: unknown result")

  def getDataFrameAncestry(self, dataFrameId):
    """
    Parameters:
     - dataFrameId
    """
    self.send_getDataFrameAncestry(dataFrameId)
    return self.recv_getDataFrameAncestry()

  def send_getDataFrameAncestry(self, dataFrameId):
    self._oprot.writeMessageBegin('getDataFrameAncestry', TMessageType.CALL, self._seqid)
    args = getDataFrameAncestry_args()
    args.dataFrameId = dataFrameId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDataFrameAncestry(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getDataFrameAncestry_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataFrameAncestry failed: unknown result")

  def getCommonAncestor(self, dfId1, dfId2):
    """
    Parameters:
     - dfId1
     - dfId2
    """
    self.send_getCommonAncestor(dfId1, dfId2)
    return self.recv_getCommonAncestor()

  def send_getCommonAncestor(self, dfId1, dfId2):
    self._oprot.writeMessageBegin('getCommonAncestor', TMessageType.CALL, self._seqid)
    args = getCommonAncestor_args()
    args.dfId1 = dfId1
    args.dfId2 = dfId2
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCommonAncestor(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCommonAncestor_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommonAncestor failed: unknown result")

  def getCommonAncestorForModels(self, modelId1, modelId2):
    """
    Parameters:
     - modelId1
     - modelId2
    """
    self.send_getCommonAncestorForModels(modelId1, modelId2)
    return self.recv_getCommonAncestorForModels()

  def send_getCommonAncestorForModels(self, modelId1, modelId2):
    self._oprot.writeMessageBegin('getCommonAncestorForModels', TMessageType.CALL, self._seqid)
    args = getCommonAncestorForModels_args()
    args.modelId1 = modelId1
    args.modelId2 = modelId2
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCommonAncestorForModels(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCommonAncestorForModels_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommonAncestorForModels failed: unknown result")

  def getTrainingRowsCount(self, modelId):
    """
    Parameters:
     - modelId
    """
    self.send_getTrainingRowsCount(modelId)
    return self.recv_getTrainingRowsCount()

  def send_getTrainingRowsCount(self, modelId):
    self._oprot.writeMessageBegin('getTrainingRowsCount', TMessageType.CALL, self._seqid)
    args = getTrainingRowsCount_args()
    args.modelId = modelId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTrainingRowsCount(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getTrainingRowsCount_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTrainingRowsCount failed: unknown result")

  def getTrainingRowsCounts(self, modelIds):
    """
    Parameters:
     - modelIds
    """
    self.send_getTrainingRowsCounts(modelIds)
    return self.recv_getTrainingRowsCounts()

  def send_getTrainingRowsCounts(self, modelIds):
    self._oprot.writeMessageBegin('getTrainingRowsCounts', TMessageType.CALL, self._seqid)
    args = getTrainingRowsCounts_args()
    args.modelIds = modelIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTrainingRowsCounts(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getTrainingRowsCounts_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTrainingRowsCounts failed: unknown result")

  def compareHyperparameters(self, modelId1, modelId2):
    """
    Parameters:
     - modelId1
     - modelId2
    """
    self.send_compareHyperparameters(modelId1, modelId2)
    return self.recv_compareHyperparameters()

  def send_compareHyperparameters(self, modelId1, modelId2):
    self._oprot.writeMessageBegin('compareHyperparameters', TMessageType.CALL, self._seqid)
    args = compareHyperparameters_args()
    args.modelId1 = modelId1
    args.modelId2 = modelId2
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_compareHyperparameters(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = compareHyperparameters_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "compareHyperparameters failed: unknown result")

  def compareFeatures(self, modelId1, modelId2):
    """
    Parameters:
     - modelId1
     - modelId2
    """
    self.send_compareFeatures(modelId1, modelId2)
    return self.recv_compareFeatures()

  def send_compareFeatures(self, modelId1, modelId2):
    self._oprot.writeMessageBegin('compareFeatures', TMessageType.CALL, self._seqid)
    args = compareFeatures_args()
    args.modelId1 = modelId1
    args.modelId2 = modelId2
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_compareFeatures(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = compareFeatures_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "compareFeatures failed: unknown result")

  def groupByProblemType(self, modelIds):
    """
    Parameters:
     - modelIds
    """
    self.send_groupByProblemType(modelIds)
    return self.recv_groupByProblemType()

  def send_groupByProblemType(self, modelIds):
    self._oprot.writeMessageBegin('groupByProblemType', TMessageType.CALL, self._seqid)
    args = groupByProblemType_args()
    args.modelIds = modelIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_groupByProblemType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = groupByProblemType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "groupByProblemType failed: unknown result")

  def similarModels(self, modelId, compMetrics, numModels):
    """
    Parameters:
     - modelId
     - compMetrics
     - numModels
    """
    self.send_similarModels(modelId, compMetrics, numModels)
    return self.recv_similarModels()

  def send_similarModels(self, modelId, compMetrics, numModels):
    self._oprot.writeMessageBegin('similarModels', TMessageType.CALL, self._seqid)
    args = similarModels_args()
    args.modelId = modelId
    args.compMetrics = compMetrics
    args.numModels = numModels
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_similarModels(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = similarModels_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    if result.brEx is not None:
      raise result.brEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "similarModels failed: unknown result")

  def linearModelFeatureImportances(self, modelId):
    """
    Parameters:
     - modelId
    """
    self.send_linearModelFeatureImportances(modelId)
    return self.recv_linearModelFeatureImportances()

  def send_linearModelFeatureImportances(self, modelId):
    self._oprot.writeMessageBegin('linearModelFeatureImportances', TMessageType.CALL, self._seqid)
    args = linearModelFeatureImportances_args()
    args.modelId = modelId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_linearModelFeatureImportances(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = linearModelFeatureImportances_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    if result.ioEx is not None:
      raise result.ioEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "linearModelFeatureImportances failed: unknown result")

  def compareLinearModelFeatureImportances(self, model1Id, model2Id):
    """
    Parameters:
     - model1Id
     - model2Id
    """
    self.send_compareLinearModelFeatureImportances(model1Id, model2Id)
    return self.recv_compareLinearModelFeatureImportances()

  def send_compareLinearModelFeatureImportances(self, model1Id, model2Id):
    self._oprot.writeMessageBegin('compareLinearModelFeatureImportances', TMessageType.CALL, self._seqid)
    args = compareLinearModelFeatureImportances_args()
    args.model1Id = model1Id
    args.model2Id = model2Id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_compareLinearModelFeatureImportances(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = compareLinearModelFeatureImportances_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    if result.ioEx is not None:
      raise result.ioEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "compareLinearModelFeatureImportances failed: unknown result")

  def iterationsUntilConvergence(self, modelIds, tolerance):
    """
    Parameters:
     - modelIds
     - tolerance
    """
    self.send_iterationsUntilConvergence(modelIds, tolerance)
    return self.recv_iterationsUntilConvergence()

  def send_iterationsUntilConvergence(self, modelIds, tolerance):
    self._oprot.writeMessageBegin('iterationsUntilConvergence', TMessageType.CALL, self._seqid)
    args = iterationsUntilConvergence_args()
    args.modelIds = modelIds
    args.tolerance = tolerance
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_iterationsUntilConvergence(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = iterationsUntilConvergence_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "iterationsUntilConvergence failed: unknown result")

  def rankModels(self, modelIds, metric):
    """
    Parameters:
     - modelIds
     - metric
    """
    self.send_rankModels(modelIds, metric)
    return self.recv_rankModels()

  def send_rankModels(self, modelIds, metric):
    self._oprot.writeMessageBegin('rankModels', TMessageType.CALL, self._seqid)
    args = rankModels_args()
    args.modelIds = modelIds
    args.metric = metric
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rankModels(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = rankModels_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "rankModels failed: unknown result")

  def confidenceIntervals(self, modelId, sigLevel):
    """
    Parameters:
     - modelId
     - sigLevel
    """
    self.send_confidenceIntervals(modelId, sigLevel)
    return self.recv_confidenceIntervals()

  def send_confidenceIntervals(self, modelId, sigLevel):
    self._oprot.writeMessageBegin('confidenceIntervals', TMessageType.CALL, self._seqid)
    args = confidenceIntervals_args()
    args.modelId = modelId
    args.sigLevel = sigLevel
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_confidenceIntervals(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = confidenceIntervals_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    if result.ioEx is not None:
      raise result.ioEx
    if result.brEx is not None:
      raise result.brEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "confidenceIntervals failed: unknown result")

  def modelsWithFeatures(self, featureNames):
    """
    Parameters:
     - featureNames
    """
    self.send_modelsWithFeatures(featureNames)
    return self.recv_modelsWithFeatures()

  def send_modelsWithFeatures(self, featureNames):
    self._oprot.writeMessageBegin('modelsWithFeatures', TMessageType.CALL, self._seqid)
    args = modelsWithFeatures_args()
    args.featureNames = featureNames
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modelsWithFeatures(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = modelsWithFeatures_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modelsWithFeatures failed: unknown result")

  def modelsDerivedFromDataFrame(self, dfId):
    """
    Parameters:
     - dfId
    """
    self.send_modelsDerivedFromDataFrame(dfId)
    return self.recv_modelsDerivedFromDataFrame()

  def send_modelsDerivedFromDataFrame(self, dfId):
    self._oprot.writeMessageBegin('modelsDerivedFromDataFrame', TMessageType.CALL, self._seqid)
    args = modelsDerivedFromDataFrame_args()
    args.dfId = dfId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modelsDerivedFromDataFrame(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = modelsDerivedFromDataFrame_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.rnfEx is not None:
      raise result.rnfEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modelsDerivedFromDataFrame failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["testConnection"] = Processor.process_testConnection
    self._processMap["pathForTransformer"] = Processor.process_pathForTransformer
    self._processMap["storeFitEvent"] = Processor.process_storeFitEvent
    self._processMap["storeMetricEvent"] = Processor.process_storeMetricEvent
    self._processMap["storeTransformEvent"] = Processor.process_storeTransformEvent
    self._processMap["storeRandomSplitEvent"] = Processor.process_storeRandomSplitEvent
    self._processMap["storePipelineEvent"] = Processor.process_storePipelineEvent
    self._processMap["storeCrossValidationEvent"] = Processor.process_storeCrossValidationEvent
    self._processMap["storeGridSearchCrossValidationEvent"] = Processor.process_storeGridSearchCrossValidationEvent
    self._processMap["storeAnnotationEvent"] = Processor.process_storeAnnotationEvent
    self._processMap["storeProjectEvent"] = Processor.process_storeProjectEvent
    self._processMap["storeExperimentEvent"] = Processor.process_storeExperimentEvent
    self._processMap["storeExperimentRunEvent"] = Processor.process_storeExperimentRunEvent
    self._processMap["storeLinearModel"] = Processor.process_storeLinearModel
    self._processMap["getDataFrameAncestry"] = Processor.process_getDataFrameAncestry
    self._processMap["getCommonAncestor"] = Processor.process_getCommonAncestor
    self._processMap["getCommonAncestorForModels"] = Processor.process_getCommonAncestorForModels
    self._processMap["getTrainingRowsCount"] = Processor.process_getTrainingRowsCount
    self._processMap["getTrainingRowsCounts"] = Processor.process_getTrainingRowsCounts
    self._processMap["compareHyperparameters"] = Processor.process_compareHyperparameters
    self._processMap["compareFeatures"] = Processor.process_compareFeatures
    self._processMap["groupByProblemType"] = Processor.process_groupByProblemType
    self._processMap["similarModels"] = Processor.process_similarModels
    self._processMap["linearModelFeatureImportances"] = Processor.process_linearModelFeatureImportances
    self._processMap["compareLinearModelFeatureImportances"] = Processor.process_compareLinearModelFeatureImportances
    self._processMap["iterationsUntilConvergence"] = Processor.process_iterationsUntilConvergence
    self._processMap["rankModels"] = Processor.process_rankModels
    self._processMap["confidenceIntervals"] = Processor.process_confidenceIntervals
    self._processMap["modelsWithFeatures"] = Processor.process_modelsWithFeatures
    self._processMap["modelsDerivedFromDataFrame"] = Processor.process_modelsDerivedFromDataFrame

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_testConnection(self, seqid, iprot, oprot):
    args = testConnection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testConnection_result()
    try:
      result.success = self._handler.testConnection()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("testConnection", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pathForTransformer(self, seqid, iprot, oprot):
    args = pathForTransformer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pathForTransformer_result()
    try:
      result.success = self._handler.pathForTransformer(args.transformerId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except InvalidFieldException as efEx:
      msg_type = TMessageType.REPLY
      result.efEx = efEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("pathForTransformer", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeFitEvent(self, seqid, iprot, oprot):
    args = storeFitEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeFitEvent_result()
    try:
      result.success = self._handler.storeFitEvent(args.fe)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidExperimentRunException as ierEx:
      msg_type = TMessageType.REPLY
      result.ierEx = ierEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeFitEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeMetricEvent(self, seqid, iprot, oprot):
    args = storeMetricEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeMetricEvent_result()
    try:
      result.success = self._handler.storeMetricEvent(args.me)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidExperimentRunException as ierEx:
      msg_type = TMessageType.REPLY
      result.ierEx = ierEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeMetricEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeTransformEvent(self, seqid, iprot, oprot):
    args = storeTransformEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeTransformEvent_result()
    try:
      result.success = self._handler.storeTransformEvent(args.te)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except InvalidExperimentRunException as ierEx:
      msg_type = TMessageType.REPLY
      result.ierEx = ierEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeTransformEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeRandomSplitEvent(self, seqid, iprot, oprot):
    args = storeRandomSplitEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeRandomSplitEvent_result()
    try:
      result.success = self._handler.storeRandomSplitEvent(args.rse)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeRandomSplitEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storePipelineEvent(self, seqid, iprot, oprot):
    args = storePipelineEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storePipelineEvent_result()
    try:
      result.success = self._handler.storePipelineEvent(args.pipelineEvent)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storePipelineEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeCrossValidationEvent(self, seqid, iprot, oprot):
    args = storeCrossValidationEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeCrossValidationEvent_result()
    try:
      result.success = self._handler.storeCrossValidationEvent(args.cve)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeCrossValidationEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeGridSearchCrossValidationEvent(self, seqid, iprot, oprot):
    args = storeGridSearchCrossValidationEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeGridSearchCrossValidationEvent_result()
    try:
      result.success = self._handler.storeGridSearchCrossValidationEvent(args.gscve)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeGridSearchCrossValidationEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeAnnotationEvent(self, seqid, iprot, oprot):
    args = storeAnnotationEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeAnnotationEvent_result()
    try:
      result.success = self._handler.storeAnnotationEvent(args.ae)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeAnnotationEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeProjectEvent(self, seqid, iprot, oprot):
    args = storeProjectEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeProjectEvent_result()
    try:
      result.success = self._handler.storeProjectEvent(args.pr)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeProjectEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeExperimentEvent(self, seqid, iprot, oprot):
    args = storeExperimentEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeExperimentEvent_result()
    try:
      result.success = self._handler.storeExperimentEvent(args.er)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeExperimentEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeExperimentRunEvent(self, seqid, iprot, oprot):
    args = storeExperimentRunEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeExperimentRunEvent_result()
    try:
      result.success = self._handler.storeExperimentRunEvent(args.er)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeExperimentRunEvent", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeLinearModel(self, seqid, iprot, oprot):
    args = storeLinearModel_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeLinearModel_result()
    try:
      result.success = self._handler.storeLinearModel(args.modelId, args.model)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("storeLinearModel", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDataFrameAncestry(self, seqid, iprot, oprot):
    args = getDataFrameAncestry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDataFrameAncestry_result()
    try:
      result.success = self._handler.getDataFrameAncestry(args.dataFrameId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getDataFrameAncestry", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCommonAncestor(self, seqid, iprot, oprot):
    args = getCommonAncestor_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCommonAncestor_result()
    try:
      result.success = self._handler.getCommonAncestor(args.dfId1, args.dfId2)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCommonAncestor", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCommonAncestorForModels(self, seqid, iprot, oprot):
    args = getCommonAncestorForModels_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCommonAncestorForModels_result()
    try:
      result.success = self._handler.getCommonAncestorForModels(args.modelId1, args.modelId2)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCommonAncestorForModels", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTrainingRowsCount(self, seqid, iprot, oprot):
    args = getTrainingRowsCount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTrainingRowsCount_result()
    try:
      result.success = self._handler.getTrainingRowsCount(args.modelId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getTrainingRowsCount", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTrainingRowsCounts(self, seqid, iprot, oprot):
    args = getTrainingRowsCounts_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTrainingRowsCounts_result()
    try:
      result.success = self._handler.getTrainingRowsCounts(args.modelIds)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getTrainingRowsCounts", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_compareHyperparameters(self, seqid, iprot, oprot):
    args = compareHyperparameters_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = compareHyperparameters_result()
    try:
      result.success = self._handler.compareHyperparameters(args.modelId1, args.modelId2)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("compareHyperparameters", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_compareFeatures(self, seqid, iprot, oprot):
    args = compareFeatures_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = compareFeatures_result()
    try:
      result.success = self._handler.compareFeatures(args.modelId1, args.modelId2)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("compareFeatures", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_groupByProblemType(self, seqid, iprot, oprot):
    args = groupByProblemType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = groupByProblemType_result()
    try:
      result.success = self._handler.groupByProblemType(args.modelIds)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("groupByProblemType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_similarModels(self, seqid, iprot, oprot):
    args = similarModels_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = similarModels_result()
    try:
      result.success = self._handler.similarModels(args.modelId, args.compMetrics, args.numModels)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except BadRequestException as brEx:
      msg_type = TMessageType.REPLY
      result.brEx = brEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("similarModels", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_linearModelFeatureImportances(self, seqid, iprot, oprot):
    args = linearModelFeatureImportances_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = linearModelFeatureImportances_result()
    try:
      result.success = self._handler.linearModelFeatureImportances(args.modelId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except IllegalOperationException as ioEx:
      msg_type = TMessageType.REPLY
      result.ioEx = ioEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("linearModelFeatureImportances", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_compareLinearModelFeatureImportances(self, seqid, iprot, oprot):
    args = compareLinearModelFeatureImportances_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = compareLinearModelFeatureImportances_result()
    try:
      result.success = self._handler.compareLinearModelFeatureImportances(args.model1Id, args.model2Id)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except IllegalOperationException as ioEx:
      msg_type = TMessageType.REPLY
      result.ioEx = ioEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("compareLinearModelFeatureImportances", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_iterationsUntilConvergence(self, seqid, iprot, oprot):
    args = iterationsUntilConvergence_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = iterationsUntilConvergence_result()
    try:
      result.success = self._handler.iterationsUntilConvergence(args.modelIds, args.tolerance)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("iterationsUntilConvergence", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rankModels(self, seqid, iprot, oprot):
    args = rankModels_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rankModels_result()
    try:
      result.success = self._handler.rankModels(args.modelIds, args.metric)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("rankModels", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_confidenceIntervals(self, seqid, iprot, oprot):
    args = confidenceIntervals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = confidenceIntervals_result()
    try:
      result.success = self._handler.confidenceIntervals(args.modelId, args.sigLevel)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except IllegalOperationException as ioEx:
      msg_type = TMessageType.REPLY
      result.ioEx = ioEx
    except BadRequestException as brEx:
      msg_type = TMessageType.REPLY
      result.brEx = brEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("confidenceIntervals", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modelsWithFeatures(self, seqid, iprot, oprot):
    args = modelsWithFeatures_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modelsWithFeatures_result()
    try:
      result.success = self._handler.modelsWithFeatures(args.featureNames)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("modelsWithFeatures", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modelsDerivedFromDataFrame(self, seqid, iprot, oprot):
    args = modelsDerivedFromDataFrame_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modelsDerivedFromDataFrame_result()
    try:
      result.success = self._handler.modelsDerivedFromDataFrame(args.dfId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except ResourceNotFoundException as rnfEx:
      msg_type = TMessageType.REPLY
      result.rnfEx = rnfEx
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("modelsDerivedFromDataFrame", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class testConnection_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testConnection_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testConnection_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testConnection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pathForTransformer_args:
  """
  Attributes:
   - transformerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'transformerId', None, None, ), # 1
  )

  def __init__(self, transformerId=None,):
    self.transformerId = transformerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.transformerId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pathForTransformer_args')
    if self.transformerId is not None:
      oprot.writeFieldBegin('transformerId', TType.I32, 1)
      oprot.writeI32(self.transformerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.transformerId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pathForTransformer_result:
  """
  Attributes:
   - success
   - rnfEx
   - efEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'efEx', (InvalidFieldException, InvalidFieldException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, rnfEx=None, efEx=None,):
    self.success = success
    self.rnfEx = rnfEx
    self.efEx = efEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.efEx = InvalidFieldException()
          self.efEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pathForTransformer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    if self.efEx is not None:
      oprot.writeFieldBegin('efEx', TType.STRUCT, 2)
      self.efEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    value = (value * 31) ^ hash(self.efEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeFitEvent_args:
  """
  Attributes:
   - fe
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fe', (FitEvent, FitEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, fe=None,):
    self.fe = fe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fe = FitEvent()
          self.fe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeFitEvent_args')
    if self.fe is not None:
      oprot.writeFieldBegin('fe', TType.STRUCT, 1)
      self.fe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.fe)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeFitEvent_result:
  """
  Attributes:
   - success
   - ierEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (FitEventResponse, FitEventResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ierEx=None,):
    self.success = success
    self.ierEx = ierEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = FitEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ierEx = InvalidExperimentRunException()
          self.ierEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeFitEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ierEx is not None:
      oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
      self.ierEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ierEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeMetricEvent_args:
  """
  Attributes:
   - me
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'me', (MetricEvent, MetricEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, me=None,):
    self.me = me

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.me = MetricEvent()
          self.me.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeMetricEvent_args')
    if self.me is not None:
      oprot.writeFieldBegin('me', TType.STRUCT, 1)
      self.me.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.me)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeMetricEvent_result:
  """
  Attributes:
   - success
   - ierEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MetricEventResponse, MetricEventResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ierEx=None,):
    self.success = success
    self.ierEx = ierEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MetricEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ierEx = InvalidExperimentRunException()
          self.ierEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeMetricEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ierEx is not None:
      oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
      self.ierEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ierEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeTransformEvent_args:
  """
  Attributes:
   - te
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'te', (TransformEvent, TransformEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, te=None,):
    self.te = te

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.te = TransformEvent()
          self.te.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeTransformEvent_args')
    if self.te is not None:
      oprot.writeFieldBegin('te', TType.STRUCT, 1)
      self.te.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.te)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeTransformEvent_result:
  """
  Attributes:
   - success
   - ierEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TransformEventResponse, TransformEventResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ierEx', (InvalidExperimentRunException, InvalidExperimentRunException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ierEx=None,):
    self.success = success
    self.ierEx = ierEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TransformEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ierEx = InvalidExperimentRunException()
          self.ierEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeTransformEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ierEx is not None:
      oprot.writeFieldBegin('ierEx', TType.STRUCT, 1)
      self.ierEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ierEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeRandomSplitEvent_args:
  """
  Attributes:
   - rse
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'rse', (RandomSplitEvent, RandomSplitEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, rse=None,):
    self.rse = rse

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.rse = RandomSplitEvent()
          self.rse.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeRandomSplitEvent_args')
    if self.rse is not None:
      oprot.writeFieldBegin('rse', TType.STRUCT, 1)
      self.rse.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.rse)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeRandomSplitEvent_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RandomSplitEventResponse, RandomSplitEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RandomSplitEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeRandomSplitEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storePipelineEvent_args:
  """
  Attributes:
   - pipelineEvent
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pipelineEvent', (PipelineEvent, PipelineEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, pipelineEvent=None,):
    self.pipelineEvent = pipelineEvent

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pipelineEvent = PipelineEvent()
          self.pipelineEvent.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storePipelineEvent_args')
    if self.pipelineEvent is not None:
      oprot.writeFieldBegin('pipelineEvent', TType.STRUCT, 1)
      self.pipelineEvent.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pipelineEvent)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storePipelineEvent_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PipelineEventResponse, PipelineEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PipelineEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storePipelineEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeCrossValidationEvent_args:
  """
  Attributes:
   - cve
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'cve', (CrossValidationEvent, CrossValidationEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, cve=None,):
    self.cve = cve

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.cve = CrossValidationEvent()
          self.cve.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeCrossValidationEvent_args')
    if self.cve is not None:
      oprot.writeFieldBegin('cve', TType.STRUCT, 1)
      self.cve.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cve)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeCrossValidationEvent_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CrossValidationEventResponse, CrossValidationEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CrossValidationEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeCrossValidationEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeGridSearchCrossValidationEvent_args:
  """
  Attributes:
   - gscve
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'gscve', (GridSearchCrossValidationEvent, GridSearchCrossValidationEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, gscve=None,):
    self.gscve = gscve

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.gscve = GridSearchCrossValidationEvent()
          self.gscve.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeGridSearchCrossValidationEvent_args')
    if self.gscve is not None:
      oprot.writeFieldBegin('gscve', TType.STRUCT, 1)
      self.gscve.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.gscve)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeGridSearchCrossValidationEvent_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GridSearchCrossValidationEventResponse, GridSearchCrossValidationEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GridSearchCrossValidationEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeGridSearchCrossValidationEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeAnnotationEvent_args:
  """
  Attributes:
   - ae
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ae', (AnnotationEvent, AnnotationEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, ae=None,):
    self.ae = ae

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ae = AnnotationEvent()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeAnnotationEvent_args')
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 1)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ae)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeAnnotationEvent_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AnnotationEventResponse, AnnotationEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AnnotationEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeAnnotationEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeProjectEvent_args:
  """
  Attributes:
   - pr
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pr', (ProjectEvent, ProjectEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, pr=None,):
    self.pr = pr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pr = ProjectEvent()
          self.pr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeProjectEvent_args')
    if self.pr is not None:
      oprot.writeFieldBegin('pr', TType.STRUCT, 1)
      self.pr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.pr)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeProjectEvent_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ProjectEventResponse, ProjectEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ProjectEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeProjectEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeExperimentEvent_args:
  """
  Attributes:
   - er
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'er', (ExperimentEvent, ExperimentEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, er=None,):
    self.er = er

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.er = ExperimentEvent()
          self.er.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeExperimentEvent_args')
    if self.er is not None:
      oprot.writeFieldBegin('er', TType.STRUCT, 1)
      self.er.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.er)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeExperimentEvent_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ExperimentEventResponse, ExperimentEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExperimentEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeExperimentEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeExperimentRunEvent_args:
  """
  Attributes:
   - er
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'er', (ExperimentRunEvent, ExperimentRunEvent.thrift_spec), None, ), # 1
  )

  def __init__(self, er=None,):
    self.er = er

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.er = ExperimentRunEvent()
          self.er.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeExperimentRunEvent_args')
    if self.er is not None:
      oprot.writeFieldBegin('er', TType.STRUCT, 1)
      self.er.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.er)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeExperimentRunEvent_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ExperimentRunEventResponse, ExperimentRunEventResponse.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExperimentRunEventResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeExperimentRunEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeLinearModel_args:
  """
  Attributes:
   - modelId
   - model
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId', None, None, ), # 1
    (2, TType.STRUCT, 'model', (LinearModel, LinearModel.thrift_spec), None, ), # 2
  )

  def __init__(self, modelId=None, model=None,):
    self.modelId = modelId
    self.model = model

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.model = LinearModel()
          self.model.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeLinearModel_args')
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.I32, 1)
      oprot.writeI32(self.modelId)
      oprot.writeFieldEnd()
    if self.model is not None:
      oprot.writeFieldBegin('model', TType.STRUCT, 2)
      self.model.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId)
    value = (value * 31) ^ hash(self.model)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeLinearModel_result:
  """
  Attributes:
   - success
   - rnfEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, rnfEx=None,):
    self.success = success
    self.rnfEx = rnfEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeLinearModel_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataFrameAncestry_args:
  """
  Attributes:
   - dataFrameId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dataFrameId', None, None, ), # 1
  )

  def __init__(self, dataFrameId=None,):
    self.dataFrameId = dataFrameId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dataFrameId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataFrameAncestry_args')
    if self.dataFrameId is not None:
      oprot.writeFieldBegin('dataFrameId', TType.I32, 1)
      oprot.writeI32(self.dataFrameId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dataFrameId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataFrameAncestry_result:
  """
  Attributes:
   - success
   - rnfEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DataFrameAncestry, DataFrameAncestry.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, rnfEx=None,):
    self.success = success
    self.rnfEx = rnfEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DataFrameAncestry()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataFrameAncestry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCommonAncestor_args:
  """
  Attributes:
   - dfId1
   - dfId2
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dfId1', None, None, ), # 1
    (2, TType.I32, 'dfId2', None, None, ), # 2
  )

  def __init__(self, dfId1=None, dfId2=None,):
    self.dfId1 = dfId1
    self.dfId2 = dfId2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dfId1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dfId2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCommonAncestor_args')
    if self.dfId1 is not None:
      oprot.writeFieldBegin('dfId1', TType.I32, 1)
      oprot.writeI32(self.dfId1)
      oprot.writeFieldEnd()
    if self.dfId2 is not None:
      oprot.writeFieldBegin('dfId2', TType.I32, 2)
      oprot.writeI32(self.dfId2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dfId1)
    value = (value * 31) ^ hash(self.dfId2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCommonAncestor_result:
  """
  Attributes:
   - success
   - rnfEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CommonAncestor, CommonAncestor.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, rnfEx=None,):
    self.success = success
    self.rnfEx = rnfEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CommonAncestor()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCommonAncestor_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCommonAncestorForModels_args:
  """
  Attributes:
   - modelId1
   - modelId2
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId1', None, None, ), # 1
    (2, TType.I32, 'modelId2', None, None, ), # 2
  )

  def __init__(self, modelId1=None, modelId2=None,):
    self.modelId1 = modelId1
    self.modelId2 = modelId2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.modelId2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCommonAncestorForModels_args')
    if self.modelId1 is not None:
      oprot.writeFieldBegin('modelId1', TType.I32, 1)
      oprot.writeI32(self.modelId1)
      oprot.writeFieldEnd()
    if self.modelId2 is not None:
      oprot.writeFieldBegin('modelId2', TType.I32, 2)
      oprot.writeI32(self.modelId2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId1)
    value = (value * 31) ^ hash(self.modelId2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCommonAncestorForModels_result:
  """
  Attributes:
   - success
   - rnfEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CommonAncestor, CommonAncestor.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, rnfEx=None,):
    self.success = success
    self.rnfEx = rnfEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CommonAncestor()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCommonAncestorForModels_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTrainingRowsCount_args:
  """
  Attributes:
   - modelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId', None, None, ), # 1
  )

  def __init__(self, modelId=None,):
    self.modelId = modelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTrainingRowsCount_args')
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.I32, 1)
      oprot.writeI32(self.modelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTrainingRowsCount_result:
  """
  Attributes:
   - success
   - rnfEx
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, rnfEx=None,):
    self.success = success
    self.rnfEx = rnfEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTrainingRowsCount_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTrainingRowsCounts_args:
  """
  Attributes:
   - modelIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'modelIds', (TType.I32,None), None, ), # 1
  )

  def __init__(self, modelIds=None,):
    self.modelIds = modelIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.modelIds = []
          (_etype247, _size244) = iprot.readListBegin()
          for _i248 in xrange(_size244):
            _elem249 = iprot.readI32()
            self.modelIds.append(_elem249)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTrainingRowsCounts_args')
    if self.modelIds is not None:
      oprot.writeFieldBegin('modelIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.modelIds))
      for iter250 in self.modelIds:
        oprot.writeI32(iter250)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTrainingRowsCounts_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype254, _size251) = iprot.readListBegin()
          for _i255 in xrange(_size251):
            _elem256 = iprot.readI32()
            self.success.append(_elem256)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTrainingRowsCounts_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter257 in self.success:
        oprot.writeI32(iter257)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compareHyperparameters_args:
  """
  Attributes:
   - modelId1
   - modelId2
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId1', None, None, ), # 1
    (2, TType.I32, 'modelId2', None, None, ), # 2
  )

  def __init__(self, modelId1=None, modelId2=None,):
    self.modelId1 = modelId1
    self.modelId2 = modelId2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.modelId2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compareHyperparameters_args')
    if self.modelId1 is not None:
      oprot.writeFieldBegin('modelId1', TType.I32, 1)
      oprot.writeI32(self.modelId1)
      oprot.writeFieldEnd()
    if self.modelId2 is not None:
      oprot.writeFieldBegin('modelId2', TType.I32, 2)
      oprot.writeI32(self.modelId2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId1)
    value = (value * 31) ^ hash(self.modelId2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compareHyperparameters_result:
  """
  Attributes:
   - success
   - rnfEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CompareHyperParametersResponse, CompareHyperParametersResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, rnfEx=None,):
    self.success = success
    self.rnfEx = rnfEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CompareHyperParametersResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compareHyperparameters_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compareFeatures_args:
  """
  Attributes:
   - modelId1
   - modelId2
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId1', None, None, ), # 1
    (2, TType.I32, 'modelId2', None, None, ), # 2
  )

  def __init__(self, modelId1=None, modelId2=None,):
    self.modelId1 = modelId1
    self.modelId2 = modelId2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.modelId2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compareFeatures_args')
    if self.modelId1 is not None:
      oprot.writeFieldBegin('modelId1', TType.I32, 1)
      oprot.writeI32(self.modelId1)
      oprot.writeFieldEnd()
    if self.modelId2 is not None:
      oprot.writeFieldBegin('modelId2', TType.I32, 2)
      oprot.writeI32(self.modelId2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId1)
    value = (value * 31) ^ hash(self.modelId2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compareFeatures_result:
  """
  Attributes:
   - success
   - rnfEx
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CompareFeaturesResponse, CompareFeaturesResponse.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, rnfEx=None,):
    self.success = success
    self.rnfEx = rnfEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CompareFeaturesResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compareFeatures_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class groupByProblemType_args:
  """
  Attributes:
   - modelIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'modelIds', (TType.I32,None), None, ), # 1
  )

  def __init__(self, modelIds=None,):
    self.modelIds = modelIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.modelIds = []
          (_etype261, _size258) = iprot.readListBegin()
          for _i262 in xrange(_size258):
            _elem263 = iprot.readI32()
            self.modelIds.append(_elem263)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('groupByProblemType_args')
    if self.modelIds is not None:
      oprot.writeFieldBegin('modelIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.modelIds))
      for iter264 in self.modelIds:
        oprot.writeI32(iter264)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelIds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class groupByProblemType_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.LIST,(TType.I32,None)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype266, _vtype267, _size265 ) = iprot.readMapBegin()
          for _i269 in xrange(_size265):
            _key270 = iprot.readI32()
            _val271 = []
            (_etype275, _size272) = iprot.readListBegin()
            for _i276 in xrange(_size272):
              _elem277 = iprot.readI32()
              _val271.append(_elem277)
            iprot.readListEnd()
            self.success[_key270] = _val271
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('groupByProblemType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.success))
      for kiter278,viter279 in self.success.items():
        oprot.writeI32(kiter278)
        oprot.writeListBegin(TType.I32, len(viter279))
        for iter280 in viter279:
          oprot.writeI32(iter280)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class similarModels_args:
  """
  Attributes:
   - modelId
   - compMetrics
   - numModels
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId', None, None, ), # 1
    (2, TType.LIST, 'compMetrics', (TType.I32,None), None, ), # 2
    (3, TType.I32, 'numModels', None, None, ), # 3
  )

  def __init__(self, modelId=None, compMetrics=None, numModels=None,):
    self.modelId = modelId
    self.compMetrics = compMetrics
    self.numModels = numModels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.compMetrics = []
          (_etype284, _size281) = iprot.readListBegin()
          for _i285 in xrange(_size281):
            _elem286 = iprot.readI32()
            self.compMetrics.append(_elem286)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.numModels = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('similarModels_args')
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.I32, 1)
      oprot.writeI32(self.modelId)
      oprot.writeFieldEnd()
    if self.compMetrics is not None:
      oprot.writeFieldBegin('compMetrics', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.compMetrics))
      for iter287 in self.compMetrics:
        oprot.writeI32(iter287)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.numModels is not None:
      oprot.writeFieldBegin('numModels', TType.I32, 3)
      oprot.writeI32(self.numModels)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId)
    value = (value * 31) ^ hash(self.compMetrics)
    value = (value * 31) ^ hash(self.numModels)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class similarModels_result:
  """
  Attributes:
   - success
   - rnfEx
   - brEx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'brEx', (BadRequestException, BadRequestException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, rnfEx=None, brEx=None,):
    self.success = success
    self.rnfEx = rnfEx
    self.brEx = brEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype291, _size288) = iprot.readListBegin()
          for _i292 in xrange(_size288):
            _elem293 = iprot.readI32()
            self.success.append(_elem293)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.brEx = BadRequestException()
          self.brEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('similarModels_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter294 in self.success:
        oprot.writeI32(iter294)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    if self.brEx is not None:
      oprot.writeFieldBegin('brEx', TType.STRUCT, 2)
      self.brEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    value = (value * 31) ^ hash(self.brEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class linearModelFeatureImportances_args:
  """
  Attributes:
   - modelId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId', None, None, ), # 1
  )

  def __init__(self, modelId=None,):
    self.modelId = modelId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('linearModelFeatureImportances_args')
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.I32, 1)
      oprot.writeI32(self.modelId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class linearModelFeatureImportances_result:
  """
  Attributes:
   - success
   - rnfEx
   - ioEx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, rnfEx=None, ioEx=None,):
    self.success = success
    self.rnfEx = rnfEx
    self.ioEx = ioEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype298, _size295) = iprot.readListBegin()
          for _i299 in xrange(_size295):
            _elem300 = iprot.readString()
            self.success.append(_elem300)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioEx = IllegalOperationException()
          self.ioEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('linearModelFeatureImportances_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter301 in self.success:
        oprot.writeString(iter301)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    if self.ioEx is not None:
      oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
      self.ioEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    value = (value * 31) ^ hash(self.ioEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compareLinearModelFeatureImportances_args:
  """
  Attributes:
   - model1Id
   - model2Id
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'model1Id', None, None, ), # 1
    (2, TType.I32, 'model2Id', None, None, ), # 2
  )

  def __init__(self, model1Id=None, model2Id=None,):
    self.model1Id = model1Id
    self.model2Id = model2Id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.model1Id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.model2Id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compareLinearModelFeatureImportances_args')
    if self.model1Id is not None:
      oprot.writeFieldBegin('model1Id', TType.I32, 1)
      oprot.writeI32(self.model1Id)
      oprot.writeFieldEnd()
    if self.model2Id is not None:
      oprot.writeFieldBegin('model2Id', TType.I32, 2)
      oprot.writeI32(self.model2Id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.model1Id)
    value = (value * 31) ^ hash(self.model2Id)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class compareLinearModelFeatureImportances_result:
  """
  Attributes:
   - success
   - rnfEx
   - ioEx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FeatureImportanceComparison, FeatureImportanceComparison.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, rnfEx=None, ioEx=None,):
    self.success = success
    self.rnfEx = rnfEx
    self.ioEx = ioEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype305, _size302) = iprot.readListBegin()
          for _i306 in xrange(_size302):
            _elem307 = FeatureImportanceComparison()
            _elem307.read(iprot)
            self.success.append(_elem307)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioEx = IllegalOperationException()
          self.ioEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('compareLinearModelFeatureImportances_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter308 in self.success:
        iter308.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    if self.ioEx is not None:
      oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
      self.ioEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    value = (value * 31) ^ hash(self.ioEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class iterationsUntilConvergence_args:
  """
  Attributes:
   - modelIds
   - tolerance
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'modelIds', (TType.I32,None), None, ), # 1
    (2, TType.DOUBLE, 'tolerance', None, None, ), # 2
  )

  def __init__(self, modelIds=None, tolerance=None,):
    self.modelIds = modelIds
    self.tolerance = tolerance

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.modelIds = []
          (_etype312, _size309) = iprot.readListBegin()
          for _i313 in xrange(_size309):
            _elem314 = iprot.readI32()
            self.modelIds.append(_elem314)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.tolerance = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('iterationsUntilConvergence_args')
    if self.modelIds is not None:
      oprot.writeFieldBegin('modelIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.modelIds))
      for iter315 in self.modelIds:
        oprot.writeI32(iter315)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tolerance is not None:
      oprot.writeFieldBegin('tolerance', TType.DOUBLE, 2)
      oprot.writeDouble(self.tolerance)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelIds)
    value = (value * 31) ^ hash(self.tolerance)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class iterationsUntilConvergence_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype319, _size316) = iprot.readListBegin()
          for _i320 in xrange(_size316):
            _elem321 = iprot.readI32()
            self.success.append(_elem321)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('iterationsUntilConvergence_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter322 in self.success:
        oprot.writeI32(iter322)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rankModels_args:
  """
  Attributes:
   - modelIds
   - metric
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'modelIds', (TType.I32,None), None, ), # 1
    (2, TType.I32, 'metric', None, None, ), # 2
  )

  def __init__(self, modelIds=None, metric=None,):
    self.modelIds = modelIds
    self.metric = metric

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.modelIds = []
          (_etype326, _size323) = iprot.readListBegin()
          for _i327 in xrange(_size323):
            _elem328 = iprot.readI32()
            self.modelIds.append(_elem328)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.metric = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rankModels_args')
    if self.modelIds is not None:
      oprot.writeFieldBegin('modelIds', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.modelIds))
      for iter329 in self.modelIds:
        oprot.writeI32(iter329)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.metric is not None:
      oprot.writeFieldBegin('metric', TType.I32, 2)
      oprot.writeI32(self.metric)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelIds)
    value = (value * 31) ^ hash(self.metric)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rankModels_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype333, _size330) = iprot.readListBegin()
          for _i334 in xrange(_size330):
            _elem335 = iprot.readI32()
            self.success.append(_elem335)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rankModels_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter336 in self.success:
        oprot.writeI32(iter336)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class confidenceIntervals_args:
  """
  Attributes:
   - modelId
   - sigLevel
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'modelId', None, None, ), # 1
    (2, TType.DOUBLE, 'sigLevel', None, None, ), # 2
  )

  def __init__(self, modelId=None, sigLevel=None,):
    self.modelId = modelId
    self.sigLevel = sigLevel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.modelId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.sigLevel = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('confidenceIntervals_args')
    if self.modelId is not None:
      oprot.writeFieldBegin('modelId', TType.I32, 1)
      oprot.writeI32(self.modelId)
      oprot.writeFieldEnd()
    if self.sigLevel is not None:
      oprot.writeFieldBegin('sigLevel', TType.DOUBLE, 2)
      oprot.writeDouble(self.sigLevel)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.modelId)
    value = (value * 31) ^ hash(self.sigLevel)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class confidenceIntervals_result:
  """
  Attributes:
   - success
   - rnfEx
   - ioEx
   - brEx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(ConfidenceInterval, ConfidenceInterval.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ioEx', (IllegalOperationException, IllegalOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'brEx', (BadRequestException, BadRequestException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, rnfEx=None, ioEx=None, brEx=None,):
    self.success = success
    self.rnfEx = rnfEx
    self.ioEx = ioEx
    self.brEx = brEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype340, _size337) = iprot.readListBegin()
          for _i341 in xrange(_size337):
            _elem342 = ConfidenceInterval()
            _elem342.read(iprot)
            self.success.append(_elem342)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ioEx = IllegalOperationException()
          self.ioEx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.brEx = BadRequestException()
          self.brEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('confidenceIntervals_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter343 in self.success:
        iter343.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    if self.ioEx is not None:
      oprot.writeFieldBegin('ioEx', TType.STRUCT, 2)
      self.ioEx.write(oprot)
      oprot.writeFieldEnd()
    if self.brEx is not None:
      oprot.writeFieldBegin('brEx', TType.STRUCT, 3)
      self.brEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    value = (value * 31) ^ hash(self.ioEx)
    value = (value * 31) ^ hash(self.brEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modelsWithFeatures_args:
  """
  Attributes:
   - featureNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'featureNames', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, featureNames=None,):
    self.featureNames = featureNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.featureNames = []
          (_etype347, _size344) = iprot.readListBegin()
          for _i348 in xrange(_size344):
            _elem349 = iprot.readString()
            self.featureNames.append(_elem349)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modelsWithFeatures_args')
    if self.featureNames is not None:
      oprot.writeFieldBegin('featureNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.featureNames))
      for iter350 in self.featureNames:
        oprot.writeString(iter350)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.featureNames)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modelsWithFeatures_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype354, _size351) = iprot.readListBegin()
          for _i355 in xrange(_size351):
            _elem356 = iprot.readI32()
            self.success.append(_elem356)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modelsWithFeatures_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter357 in self.success:
        oprot.writeI32(iter357)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modelsDerivedFromDataFrame_args:
  """
  Attributes:
   - dfId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dfId', None, None, ), # 1
  )

  def __init__(self, dfId=None,):
    self.dfId = dfId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dfId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modelsDerivedFromDataFrame_args')
    if self.dfId is not None:
      oprot.writeFieldBegin('dfId', TType.I32, 1)
      oprot.writeI32(self.dfId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dfId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modelsDerivedFromDataFrame_result:
  """
  Attributes:
   - success
   - rnfEx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
    (1, TType.STRUCT, 'rnfEx', (ResourceNotFoundException, ResourceNotFoundException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, rnfEx=None,):
    self.success = success
    self.rnfEx = rnfEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype361, _size358) = iprot.readListBegin()
          for _i362 in xrange(_size358):
            _elem363 = iprot.readI32()
            self.success.append(_elem363)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.rnfEx = ResourceNotFoundException()
          self.rnfEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modelsDerivedFromDataFrame_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter364 in self.success:
        oprot.writeI32(iter364)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rnfEx is not None:
      oprot.writeFieldBegin('rnfEx', TType.STRUCT, 1)
      self.rnfEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.rnfEx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
