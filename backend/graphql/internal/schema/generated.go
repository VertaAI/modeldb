// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package schema

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/VertaAI/modeldb/backend/graphql/internal/schema/models"
	"github.com/VertaAI/modeldb/protos/gen/go/protos/public/common"
	"github.com/VertaAI/modeldb/protos/gen/go/protos/public/modeldb"
	"github.com/VertaAI/modeldb/protos/gen/go/protos/public/modeldb/versioning"
	"github.com/VertaAI/modeldb/protos/gen/go/protos/public/uac"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Artifact() ArtifactResolver
	Commit() CommitResolver
	CommitBlob() CommitBlobResolver
	Dataset() DatasetResolver
	DatasetVersion() DatasetVersionResolver
	Experiment() ExperimentResolver
	ExperimentRun() ExperimentRunResolver
	Mutation() MutationResolver
	NamedCommitBlob() NamedCommitBlobResolver
	NamedCommitFolder() NamedCommitFolderResolver
	Observation() ObservationResolver
	Organization() OrganizationResolver
	Project() ProjectResolver
	Query() QueryResolver
	Repository() RepositoryResolver
	RepositoryBranch() RepositoryBranchResolver
	RepositoryTag() RepositoryTagResolver
	Team() TeamResolver
	TeamCollaborator() TeamCollaboratorResolver
	User() UserResolver
	UserCollaborator() UserCollaboratorResolver
	Workspace() WorkspaceResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AllowedActions struct {
		Create func(childComplexity int) int
		Delete func(childComplexity int) int
		Deploy func(childComplexity int) int
		Update func(childComplexity int) int
	}

	Artifact struct {
		Key      func(childComplexity int) int
		Path     func(childComplexity int) int
		PathOnly func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	BranchesNetwork struct {
		Branches func(childComplexity int) int
		Commits  func(childComplexity int) int
		Edges    func(childComplexity int) int
	}

	Commit struct {
		AsDiff      func(childComplexity int) int
		Author      func(childComplexity int) int
		Date        func(childComplexity int) int
		GetLocation func(childComplexity int, location []string) int
		ID          func(childComplexity int) int
		Message     func(childComplexity int) int
		Runs        func(childComplexity int, query *ExperimentRunsQuery) int
		SetBranch   func(childComplexity int, name string) int
		SetTag      func(childComplexity int, name string) int
	}

	CommitAsDiff struct {
		Diff   func(childComplexity int) int
		Parent func(childComplexity int) int
	}

	CommitBlob struct {
		Content                 func(childComplexity int) int
		DownloadURLForComponent func(childComplexity int, componentPath string) int
		Runs                    func(childComplexity int, query *ExperimentRunsQuery) int
	}

	CommitFolder struct {
		Blobs      func(childComplexity int) int
		Subfolders func(childComplexity int) int
	}

	Commits struct {
		Commits func(childComplexity int) int
	}

	Dataset struct {
		AddTags           func(childComplexity int, tags []string) int
		AllowedActions    func(childComplexity int) int
		Attributes        func(childComplexity int) int
		ChangeDescription func(childComplexity int, description string) int
		Collaborators     func(childComplexity int) int
		DatasetVersions   func(childComplexity int, query *DatasetVersionsQuery) int
		DateCreated       func(childComplexity int) int
		DateUpdated       func(childComplexity int) int
		Delete            func(childComplexity int) int
		DeleteTags        func(childComplexity int, tags []string) int
		Description       func(childComplexity int) int
		Id                func(childComplexity int) int
		Name              func(childComplexity int) int
		Owner             func(childComplexity int) int
		Tags              func(childComplexity int) int
		Visibility        func(childComplexity int) int
	}

	DatasetVersion struct {
		AddTags           func(childComplexity int, tags []string) int
		Attributes        func(childComplexity int) int
		BlobInfo          func(childComplexity int) int
		ChangeDescription func(childComplexity int, description string) int
		Dataset           func(childComplexity int) int
		DatasetId         func(childComplexity int) int
		DateCreated       func(childComplexity int) int
		DateUpdated       func(childComplexity int) int
		Delete            func(childComplexity int) int
		DeleteTags        func(childComplexity int, tags []string) int
		Description       func(childComplexity int) int
		DownloadURL       func(childComplexity int, blobPath string) int
		Id                func(childComplexity int) int
		Owner             func(childComplexity int) int
		ParentId          func(childComplexity int) int
		PathInfo          func(childComplexity int) int
		QueryInfo         func(childComplexity int) int
		RawInfo           func(childComplexity int) int
		Runs              func(childComplexity int, query *ExperimentRunsQuery) int
		Tags              func(childComplexity int) int
		Version           func(childComplexity int) int
	}

	DatasetVersions struct {
		DatasetVersions func(childComplexity int) int
		Total           func(childComplexity int) int
	}

	Datasets struct {
		Datasets func(childComplexity int) int
		Total    func(childComplexity int) int
	}

	Experiment struct {
		Attributes  func(childComplexity int) int
		DateCreated func(childComplexity int) int
		DateUpdated func(childComplexity int) int
		Description func(childComplexity int) int
		Id          func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		Project     func(childComplexity int) int
		ProjectId   func(childComplexity int) int
		Runs        func(childComplexity int, next *string, query *ExperimentRunsQuery) int
		Tags        func(childComplexity int) int
	}

	ExperimentRun struct {
		Artifacts       func(childComplexity int) int
		Attributes      func(childComplexity int) int
		CodeVersion     func(childComplexity int) int
		Datasets        func(childComplexity int) int
		DateCreated     func(childComplexity int) int
		DateUpdated     func(childComplexity int) int
		Description     func(childComplexity int) int
		Experiment      func(childComplexity int) int
		ExperimentId    func(childComplexity int) int
		Features        func(childComplexity int) int
		Hyperparameters func(childComplexity int) int
		Id              func(childComplexity int) int
		JobId           func(childComplexity int) int
		Metrics         func(childComplexity int) int
		Name            func(childComplexity int) int
		Observations    func(childComplexity int) int
		Owner           func(childComplexity int) int
		Project         func(childComplexity int) int
		ProjectId       func(childComplexity int) int
		Tags            func(childComplexity int) int
	}

	ExperimentRuns struct {
		Next       func(childComplexity int) int
		Pagination func(childComplexity int) int
		Runs       func(childComplexity int) int
	}

	Experiments struct {
		Experiments func(childComplexity int) int
		Next        func(childComplexity int) int
	}

	Feature struct {
		Name func(childComplexity int) int
	}

	FloatKeyValue struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	MergeResult struct {
		Commit     func(childComplexity int) int
		CommonBase func(childComplexity int) int
		Conflicts  func(childComplexity int) int
	}

	Mutation struct {
		AddProjectTag          func(childComplexity int, id string, tag string) int
		AddRunTag              func(childComplexity int, id string, tag string) int
		Dataset                func(childComplexity int, id string) int
		DelCollaboratorProject func(childComplexity int, projid string, collid string) int
		DelProject             func(childComplexity int, id string) int
		DelProjectTag          func(childComplexity int, id string, tag string) int
		DelRunTag              func(childComplexity int, id string, tag string) int
		EditProjectDescription func(childComplexity int, id string, description string) int
		EditProjectReadme      func(childComplexity int, id string, readme string) int
		EditRunDescription     func(childComplexity int, id string, description string) int
		Repository             func(childComplexity int, id string) int
		SetCollaboratorProject func(childComplexity int, projid string, email string, typeArg AccessType) int
		Workspace              func(childComplexity int, name *string) int
	}

	NamedCommitBlob struct {
		Content func(childComplexity int) int
		Name    func(childComplexity int) int
	}

	NamedCommitFolder struct {
		Content func(childComplexity int) int
		Name    func(childComplexity int) int
	}

	NetworkBranchColor struct {
		Branch      func(childComplexity int) int
		Color       func(childComplexity int) int
		CommitIndex func(childComplexity int) int
	}

	NetworkCommitColor struct {
		Color  func(childComplexity int) int
		Commit func(childComplexity int) int
	}

	NetworkEdgeColor struct {
		Color           func(childComplexity int) int
		EdgeType        func(childComplexity int) int
		FromCommitIndex func(childComplexity int) int
		ToCommitIndex   func(childComplexity int) int
	}

	Observation struct {
		Artifact  func(childComplexity int) int
		Attribute func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	Organization struct {
		DateCreated func(childComplexity int) int
		DateUpdated func(childComplexity int) int
		Description func(childComplexity int) int
		Id          func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		ShortName   func(childComplexity int) int
		Teams       func(childComplexity int) int
	}

	PaginationResponse struct {
		Limit        func(childComplexity int) int
		Page         func(childComplexity int) int
		TotalRecords func(childComplexity int) int
	}

	Project struct {
		Access            func(childComplexity int) int
		Attributes        func(childComplexity int) int
		Collaborators     func(childComplexity int) int
		DateCreated       func(childComplexity int) int
		DateUpdated       func(childComplexity int) int
		Description       func(childComplexity int) int
		Experiments       func(childComplexity int, next *string, query *ExperimentsQuery) int
		Id                func(childComplexity int) int
		Name              func(childComplexity int) int
		Owner             func(childComplexity int) int
		ProjectVisibility func(childComplexity int) int
		ReadmeText        func(childComplexity int) int
		Runs              func(childComplexity int, next *string, query *ExperimentRunsQuery) int
		ShortName         func(childComplexity int) int
		Tags              func(childComplexity int) int
	}

	Projects struct {
		Next     func(childComplexity int) int
		Projects func(childComplexity int) int
	}

	Query struct {
		Dataset       func(childComplexity int, id string) int
		Experiment    func(childComplexity int, id string) int
		Organization  func(childComplexity int, id string) int
		Organizations func(childComplexity int) int
		Project       func(childComplexity int, id string) int
		Repository    func(childComplexity int, id string) int
		Run           func(childComplexity int, id string) int
		Self          func(childComplexity int) int
		Teams         func(childComplexity int) int
		Workspace     func(childComplexity int, name *string) int
	}

	Repositories struct {
		Next         func(childComplexity int) int
		Pagination   func(childComplexity int) int
		Repositories func(childComplexity int) int
	}

	Repository struct {
		AddLabels         func(childComplexity int, labels []string) int
		AllowedActions    func(childComplexity int) int
		Branch            func(childComplexity int, name string) int
		Branches          func(childComplexity int) int
		Collaborators     func(childComplexity int) int
		Commit            func(childComplexity int, id string) int
		CommitByReference func(childComplexity int, ref CommitReference) int
		DateCreated       func(childComplexity int) int
		DateUpdated       func(childComplexity int) int
		Delete            func(childComplexity int) int
		DeleteLabels      func(childComplexity int, labels []string) int
		Diff              func(childComplexity int, a CommitReference, b CommitReference) int
		ID                func(childComplexity int) int
		Labels            func(childComplexity int) int
		Log               func(childComplexity int, commit CommitReference) int
		Merge             func(childComplexity int, a CommitReference, b CommitReference, message *string, isDryRun *bool) int
		Name              func(childComplexity int) int
		Network           func(childComplexity int) int
		Owner             func(childComplexity int) int
		Tag               func(childComplexity int, name string) int
		Tags              func(childComplexity int) int
	}

	RepositoryBranch struct {
		Commit func(childComplexity int) int
		Name   func(childComplexity int) int
	}

	RepositoryTag struct {
		Commit func(childComplexity int) int
		Name   func(childComplexity int) int
	}

	StringKeyValue struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Team struct {
		DateCreated    func(childComplexity int) int
		DateUpdated    func(childComplexity int) int
		Description    func(childComplexity int) int
		Id             func(childComplexity int) int
		Name           func(childComplexity int) int
		Organization   func(childComplexity int) int
		OrganizationID func(childComplexity int) int
		Owner          func(childComplexity int) int
		ShortName      func(childComplexity int) int
	}

	TeamCollaborator struct {
		CanDeploy func(childComplexity int) int
		Team      func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	User struct {
		Email    func(childComplexity int) int
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Picture  func(childComplexity int) int
		Roles    func(childComplexity int) int
		Username func(childComplexity int) int
	}

	UserCollaborator struct {
		CanDeploy func(childComplexity int) int
		Type      func(childComplexity int) int
		User      func(childComplexity int) int
	}

	Workspace struct {
		CreateDataset    func(childComplexity int, name string, visibility Visibility) int
		CreateRepository func(childComplexity int, name string, visibility Visibility) int
		DatasetVersions  func(childComplexity int, query *DatasetVersionsQuery) int
		Datasets         func(childComplexity int, query *DatasetsQuery) int
		Name             func(childComplexity int) int
		Projects         func(childComplexity int, next *string, query *ProjectsQuery) int
		Repositories     func(childComplexity int, next *string, query *RepositoriesQuery) int
		Repository       func(childComplexity int, name string) int
	}
}

type ArtifactResolver interface {
	Type(ctx context.Context, obj *common.Artifact) (ArtifactType, error)
}
type CommitResolver interface {
	ID(ctx context.Context, obj *models.Commit) (string, error)
	Message(ctx context.Context, obj *models.Commit) (string, error)
	Date(ctx context.Context, obj *models.Commit) (string, error)
	Author(ctx context.Context, obj *models.Commit) (*uac.UserInfo, error)
	GetLocation(ctx context.Context, obj *models.Commit, location []string) (CommitElement, error)
	AsDiff(ctx context.Context, obj *models.Commit) (*CommitAsDiff, error)
	Runs(ctx context.Context, obj *models.Commit, query *ExperimentRunsQuery) (*ExperimentRuns, error)
	SetTag(ctx context.Context, obj *models.Commit, name string) (*versioning.Repository, error)
	SetBranch(ctx context.Context, obj *models.Commit, name string) (*versioning.Repository, error)
}
type CommitBlobResolver interface {
	Runs(ctx context.Context, obj *models.CommitBlob, query *ExperimentRunsQuery) (*ExperimentRuns, error)
	DownloadURLForComponent(ctx context.Context, obj *models.CommitBlob, componentPath string) (string, error)
}
type DatasetResolver interface {
	DateCreated(ctx context.Context, obj *modeldb.Dataset) (string, error)
	DateUpdated(ctx context.Context, obj *modeldb.Dataset) (string, error)
	Visibility(ctx context.Context, obj *modeldb.Dataset) (DatasetVisibility, error)
	AllowedActions(ctx context.Context, obj *modeldb.Dataset) (*AllowedActions, error)
	Attributes(ctx context.Context, obj *modeldb.Dataset) ([]KeyValue, error)

	Owner(ctx context.Context, obj *modeldb.Dataset) (*uac.UserInfo, error)
	Collaborators(ctx context.Context, obj *modeldb.Dataset) ([]Collaborator, error)
	AddTags(ctx context.Context, obj *modeldb.Dataset, tags []string) (*modeldb.Dataset, error)
	DeleteTags(ctx context.Context, obj *modeldb.Dataset, tags []string) (*modeldb.Dataset, error)
	DatasetVersions(ctx context.Context, obj *modeldb.Dataset, query *DatasetVersionsQuery) (*DatasetVersions, error)
	ChangeDescription(ctx context.Context, obj *modeldb.Dataset, description string) (*modeldb.Dataset, error)
	Delete(ctx context.Context, obj *modeldb.Dataset) (bool, error)
}
type DatasetVersionResolver interface {
	Dataset(ctx context.Context, obj *modeldb.DatasetVersion) (*modeldb.Dataset, error)

	DateCreated(ctx context.Context, obj *modeldb.DatasetVersion) (string, error)
	DateUpdated(ctx context.Context, obj *modeldb.DatasetVersion) (string, error)
	Attributes(ctx context.Context, obj *modeldb.DatasetVersion) ([]KeyValue, error)
	Owner(ctx context.Context, obj *modeldb.DatasetVersion) (*uac.UserInfo, error)
	Version(ctx context.Context, obj *modeldb.DatasetVersion) (int, error)
	DownloadURL(ctx context.Context, obj *modeldb.DatasetVersion, blobPath string) (*string, error)

	AddTags(ctx context.Context, obj *modeldb.DatasetVersion, tags []string) (*modeldb.DatasetVersion, error)
	DeleteTags(ctx context.Context, obj *modeldb.DatasetVersion, tags []string) (*modeldb.DatasetVersion, error)
	Runs(ctx context.Context, obj *modeldb.DatasetVersion, query *ExperimentRunsQuery) (*ExperimentRuns, error)
	BlobInfo(ctx context.Context, obj *modeldb.DatasetVersion) (*string, error)
	RawInfo(ctx context.Context, obj *modeldb.DatasetVersion) (*string, error)
	PathInfo(ctx context.Context, obj *modeldb.DatasetVersion) (*string, error)
	QueryInfo(ctx context.Context, obj *modeldb.DatasetVersion) (*string, error)
	ChangeDescription(ctx context.Context, obj *modeldb.DatasetVersion, description string) (*modeldb.DatasetVersion, error)
	Delete(ctx context.Context, obj *modeldb.DatasetVersion) (bool, error)
}
type ExperimentResolver interface {
	Project(ctx context.Context, obj *modeldb.Experiment) (*modeldb.Project, error)

	DateCreated(ctx context.Context, obj *modeldb.Experiment) (string, error)
	DateUpdated(ctx context.Context, obj *modeldb.Experiment) (string, error)
	Attributes(ctx context.Context, obj *modeldb.Experiment) ([]KeyValue, error)

	Owner(ctx context.Context, obj *modeldb.Experiment) (*uac.UserInfo, error)
	Runs(ctx context.Context, obj *modeldb.Experiment, next *string, query *ExperimentRunsQuery) (*ExperimentRuns, error)
}
type ExperimentRunResolver interface {
	Project(ctx context.Context, obj *modeldb.ExperimentRun) (*modeldb.Project, error)

	Experiment(ctx context.Context, obj *modeldb.ExperimentRun) (*modeldb.Experiment, error)

	DateCreated(ctx context.Context, obj *modeldb.ExperimentRun) (string, error)
	DateUpdated(ctx context.Context, obj *modeldb.ExperimentRun) (string, error)
	Attributes(ctx context.Context, obj *modeldb.ExperimentRun) ([]KeyValue, error)

	Hyperparameters(ctx context.Context, obj *modeldb.ExperimentRun) ([]KeyValue, error)

	Metrics(ctx context.Context, obj *modeldb.ExperimentRun) ([]KeyValue, error)

	Owner(ctx context.Context, obj *modeldb.ExperimentRun) (*uac.UserInfo, error)
}
type MutationResolver interface {
	EditRunDescription(ctx context.Context, id string, description string) (*modeldb.ExperimentRun, error)
	AddRunTag(ctx context.Context, id string, tag string) (*modeldb.ExperimentRun, error)
	DelRunTag(ctx context.Context, id string, tag string) (*modeldb.ExperimentRun, error)
	SetCollaboratorProject(ctx context.Context, projid string, email string, typeArg AccessType) (*modeldb.Project, error)
	DelCollaboratorProject(ctx context.Context, projid string, collid string) (*modeldb.Project, error)
	EditProjectDescription(ctx context.Context, id string, description string) (*modeldb.Project, error)
	EditProjectReadme(ctx context.Context, id string, readme string) (*modeldb.Project, error)
	AddProjectTag(ctx context.Context, id string, tag string) (*modeldb.Project, error)
	DelProjectTag(ctx context.Context, id string, tag string) (*modeldb.Project, error)
	DelProject(ctx context.Context, id string) (bool, error)
	Dataset(ctx context.Context, id string) (*modeldb.Dataset, error)
	Repository(ctx context.Context, id string) (*versioning.Repository, error)
	Workspace(ctx context.Context, name *string) (*models.Workspace, error)
}
type NamedCommitBlobResolver interface {
	Content(ctx context.Context, obj *models.NamedCommitBlob) (*models.CommitBlob, error)
}
type NamedCommitFolderResolver interface {
	Content(ctx context.Context, obj *models.NamedCommitFolder) (*CommitFolder, error)
}
type ObservationResolver interface {
	Attribute(ctx context.Context, obj *modeldb.Observation) (KeyValue, error)
	Artifact(ctx context.Context, obj *modeldb.Observation) (*common.Artifact, error)
	Timestamp(ctx context.Context, obj *modeldb.Observation) (*string, error)
}
type OrganizationResolver interface {
	Owner(ctx context.Context, obj *uac.Organization) (*uac.UserInfo, error)
	DateCreated(ctx context.Context, obj *uac.Organization) (string, error)
	DateUpdated(ctx context.Context, obj *uac.Organization) (string, error)
	Teams(ctx context.Context, obj *uac.Organization) ([]*uac.Team, error)
}
type ProjectResolver interface {
	DateCreated(ctx context.Context, obj *modeldb.Project) (string, error)
	DateUpdated(ctx context.Context, obj *modeldb.Project) (string, error)

	ProjectVisibility(ctx context.Context, obj *modeldb.Project) (ProjectVisibility, error)
	Access(ctx context.Context, obj *modeldb.Project) (AccessType, error)
	Attributes(ctx context.Context, obj *modeldb.Project) ([]KeyValue, error)

	Owner(ctx context.Context, obj *modeldb.Project) (*uac.UserInfo, error)
	Collaborators(ctx context.Context, obj *modeldb.Project) ([]Collaborator, error)
	Experiments(ctx context.Context, obj *modeldb.Project, next *string, query *ExperimentsQuery) (*Experiments, error)
	Runs(ctx context.Context, obj *modeldb.Project, next *string, query *ExperimentRunsQuery) (*ExperimentRuns, error)
}
type QueryResolver interface {
	Organizations(ctx context.Context) ([]*uac.Organization, error)
	Teams(ctx context.Context) ([]*uac.Team, error)
	Self(ctx context.Context) (*uac.UserInfo, error)
	Project(ctx context.Context, id string) (*modeldb.Project, error)
	Experiment(ctx context.Context, id string) (*modeldb.Experiment, error)
	Run(ctx context.Context, id string) (*modeldb.ExperimentRun, error)
	Dataset(ctx context.Context, id string) (*modeldb.Dataset, error)
	Repository(ctx context.Context, id string) (*versioning.Repository, error)
	Organization(ctx context.Context, id string) (*uac.Organization, error)
	Workspace(ctx context.Context, name *string) (*models.Workspace, error)
}
type RepositoryResolver interface {
	ID(ctx context.Context, obj *versioning.Repository) (string, error)

	DateCreated(ctx context.Context, obj *versioning.Repository) (string, error)
	DateUpdated(ctx context.Context, obj *versioning.Repository) (string, error)
	Labels(ctx context.Context, obj *versioning.Repository) ([]string, error)
	Owner(ctx context.Context, obj *versioning.Repository) (*uac.UserInfo, error)
	Collaborators(ctx context.Context, obj *versioning.Repository) ([]Collaborator, error)
	AllowedActions(ctx context.Context, obj *versioning.Repository) (*AllowedActions, error)
	Tags(ctx context.Context, obj *versioning.Repository) ([]*models.RepositoryTag, error)
	Branches(ctx context.Context, obj *versioning.Repository) ([]*models.RepositoryBranch, error)
	Commit(ctx context.Context, obj *versioning.Repository, id string) (*models.Commit, error)
	Tag(ctx context.Context, obj *versioning.Repository, name string) (*models.Commit, error)
	Branch(ctx context.Context, obj *versioning.Repository, name string) (*models.Commit, error)
	CommitByReference(ctx context.Context, obj *versioning.Repository, ref CommitReference) (*models.Commit, error)
	Diff(ctx context.Context, obj *versioning.Repository, a CommitReference, b CommitReference) ([]string, error)
	Log(ctx context.Context, obj *versioning.Repository, commit CommitReference) (*Commits, error)
	Network(ctx context.Context, obj *versioning.Repository) (*BranchesNetwork, error)
	Delete(ctx context.Context, obj *versioning.Repository) (bool, error)
	AddLabels(ctx context.Context, obj *versioning.Repository, labels []string) (*versioning.Repository, error)
	DeleteLabels(ctx context.Context, obj *versioning.Repository, labels []string) (*versioning.Repository, error)
	Merge(ctx context.Context, obj *versioning.Repository, a CommitReference, b CommitReference, message *string, isDryRun *bool) (*MergeResult, error)
}
type RepositoryBranchResolver interface {
	Commit(ctx context.Context, obj *models.RepositoryBranch) (*models.Commit, error)
}
type RepositoryTagResolver interface {
	Commit(ctx context.Context, obj *models.RepositoryTag) (*models.Commit, error)
}
type TeamResolver interface {
	OrganizationID(ctx context.Context, obj *uac.Team) (string, error)
	Organization(ctx context.Context, obj *uac.Team) (*uac.Organization, error)

	Owner(ctx context.Context, obj *uac.Team) (*uac.UserInfo, error)
	DateCreated(ctx context.Context, obj *uac.Team) (string, error)
	DateUpdated(ctx context.Context, obj *uac.Team) (string, error)
}
type TeamCollaboratorResolver interface {
	Team(ctx context.Context, obj *models.TeamCollaborator) (*uac.Team, error)
	Type(ctx context.Context, obj *models.TeamCollaborator) (AccessType, error)
	CanDeploy(ctx context.Context, obj *models.TeamCollaborator) (bool, error)
}
type UserResolver interface {
	ID(ctx context.Context, obj *uac.UserInfo) (string, error)
	Name(ctx context.Context, obj *uac.UserInfo) (*string, error)

	Picture(ctx context.Context, obj *uac.UserInfo) (*string, error)

	Username(ctx context.Context, obj *uac.UserInfo) (string, error)
}
type UserCollaboratorResolver interface {
	User(ctx context.Context, obj *models.UserCollaborator) (*uac.UserInfo, error)
	Type(ctx context.Context, obj *models.UserCollaborator) (AccessType, error)
	CanDeploy(ctx context.Context, obj *models.UserCollaborator) (bool, error)
}
type WorkspaceResolver interface {
	Projects(ctx context.Context, obj *models.Workspace, next *string, query *ProjectsQuery) (*Projects, error)
	Datasets(ctx context.Context, obj *models.Workspace, query *DatasetsQuery) (*Datasets, error)
	DatasetVersions(ctx context.Context, obj *models.Workspace, query *DatasetVersionsQuery) (*DatasetVersions, error)
	CreateDataset(ctx context.Context, obj *models.Workspace, name string, visibility Visibility) (*modeldb.Dataset, error)
	Repositories(ctx context.Context, obj *models.Workspace, next *string, query *RepositoriesQuery) (*Repositories, error)
	Repository(ctx context.Context, obj *models.Workspace, name string) (*versioning.Repository, error)
	CreateRepository(ctx context.Context, obj *models.Workspace, name string, visibility Visibility) (*versioning.Repository, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AllowedActions.create":
		if e.complexity.AllowedActions.Create == nil {
			break
		}

		return e.complexity.AllowedActions.Create(childComplexity), true

	case "AllowedActions.delete":
		if e.complexity.AllowedActions.Delete == nil {
			break
		}

		return e.complexity.AllowedActions.Delete(childComplexity), true

	case "AllowedActions.deploy":
		if e.complexity.AllowedActions.Deploy == nil {
			break
		}

		return e.complexity.AllowedActions.Deploy(childComplexity), true

	case "AllowedActions.update":
		if e.complexity.AllowedActions.Update == nil {
			break
		}

		return e.complexity.AllowedActions.Update(childComplexity), true

	case "Artifact.key":
		if e.complexity.Artifact.Key == nil {
			break
		}

		return e.complexity.Artifact.Key(childComplexity), true

	case "Artifact.path":
		if e.complexity.Artifact.Path == nil {
			break
		}

		return e.complexity.Artifact.Path(childComplexity), true

	case "Artifact.pathOnly":
		if e.complexity.Artifact.PathOnly == nil {
			break
		}

		return e.complexity.Artifact.PathOnly(childComplexity), true

	case "Artifact.type":
		if e.complexity.Artifact.Type == nil {
			break
		}

		return e.complexity.Artifact.Type(childComplexity), true

	case "BranchesNetwork.branches":
		if e.complexity.BranchesNetwork.Branches == nil {
			break
		}

		return e.complexity.BranchesNetwork.Branches(childComplexity), true

	case "BranchesNetwork.commits":
		if e.complexity.BranchesNetwork.Commits == nil {
			break
		}

		return e.complexity.BranchesNetwork.Commits(childComplexity), true

	case "BranchesNetwork.edges":
		if e.complexity.BranchesNetwork.Edges == nil {
			break
		}

		return e.complexity.BranchesNetwork.Edges(childComplexity), true

	case "Commit.asDiff":
		if e.complexity.Commit.AsDiff == nil {
			break
		}

		return e.complexity.Commit.AsDiff(childComplexity), true

	case "Commit.author":
		if e.complexity.Commit.Author == nil {
			break
		}

		return e.complexity.Commit.Author(childComplexity), true

	case "Commit.date":
		if e.complexity.Commit.Date == nil {
			break
		}

		return e.complexity.Commit.Date(childComplexity), true

	case "Commit.getLocation":
		if e.complexity.Commit.GetLocation == nil {
			break
		}

		args, err := ec.field_Commit_getLocation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Commit.GetLocation(childComplexity, args["location"].([]string)), true

	case "Commit.id":
		if e.complexity.Commit.ID == nil {
			break
		}

		return e.complexity.Commit.ID(childComplexity), true

	case "Commit.message":
		if e.complexity.Commit.Message == nil {
			break
		}

		return e.complexity.Commit.Message(childComplexity), true

	case "Commit.runs":
		if e.complexity.Commit.Runs == nil {
			break
		}

		args, err := ec.field_Commit_runs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Commit.Runs(childComplexity, args["query"].(*ExperimentRunsQuery)), true

	case "Commit.setBranch":
		if e.complexity.Commit.SetBranch == nil {
			break
		}

		args, err := ec.field_Commit_setBranch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Commit.SetBranch(childComplexity, args["name"].(string)), true

	case "Commit.setTag":
		if e.complexity.Commit.SetTag == nil {
			break
		}

		args, err := ec.field_Commit_setTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Commit.SetTag(childComplexity, args["name"].(string)), true

	case "CommitAsDiff.diff":
		if e.complexity.CommitAsDiff.Diff == nil {
			break
		}

		return e.complexity.CommitAsDiff.Diff(childComplexity), true

	case "CommitAsDiff.parent":
		if e.complexity.CommitAsDiff.Parent == nil {
			break
		}

		return e.complexity.CommitAsDiff.Parent(childComplexity), true

	case "CommitBlob.content":
		if e.complexity.CommitBlob.Content == nil {
			break
		}

		return e.complexity.CommitBlob.Content(childComplexity), true

	case "CommitBlob.downloadUrlForComponent":
		if e.complexity.CommitBlob.DownloadURLForComponent == nil {
			break
		}

		args, err := ec.field_CommitBlob_downloadUrlForComponent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CommitBlob.DownloadURLForComponent(childComplexity, args["componentPath"].(string)), true

	case "CommitBlob.runs":
		if e.complexity.CommitBlob.Runs == nil {
			break
		}

		args, err := ec.field_CommitBlob_runs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CommitBlob.Runs(childComplexity, args["query"].(*ExperimentRunsQuery)), true

	case "CommitFolder.blobs":
		if e.complexity.CommitFolder.Blobs == nil {
			break
		}

		return e.complexity.CommitFolder.Blobs(childComplexity), true

	case "CommitFolder.subfolders":
		if e.complexity.CommitFolder.Subfolders == nil {
			break
		}

		return e.complexity.CommitFolder.Subfolders(childComplexity), true

	case "Commits.commits":
		if e.complexity.Commits.Commits == nil {
			break
		}

		return e.complexity.Commits.Commits(childComplexity), true

	case "Dataset.addTags":
		if e.complexity.Dataset.AddTags == nil {
			break
		}

		args, err := ec.field_Dataset_addTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Dataset.AddTags(childComplexity, args["tags"].([]string)), true

	case "Dataset.allowedActions":
		if e.complexity.Dataset.AllowedActions == nil {
			break
		}

		return e.complexity.Dataset.AllowedActions(childComplexity), true

	case "Dataset.attributes":
		if e.complexity.Dataset.Attributes == nil {
			break
		}

		return e.complexity.Dataset.Attributes(childComplexity), true

	case "Dataset.changeDescription":
		if e.complexity.Dataset.ChangeDescription == nil {
			break
		}

		args, err := ec.field_Dataset_changeDescription_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Dataset.ChangeDescription(childComplexity, args["description"].(string)), true

	case "Dataset.collaborators":
		if e.complexity.Dataset.Collaborators == nil {
			break
		}

		return e.complexity.Dataset.Collaborators(childComplexity), true

	case "Dataset.datasetVersions":
		if e.complexity.Dataset.DatasetVersions == nil {
			break
		}

		args, err := ec.field_Dataset_datasetVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Dataset.DatasetVersions(childComplexity, args["query"].(*DatasetVersionsQuery)), true

	case "Dataset.dateCreated":
		if e.complexity.Dataset.DateCreated == nil {
			break
		}

		return e.complexity.Dataset.DateCreated(childComplexity), true

	case "Dataset.dateUpdated":
		if e.complexity.Dataset.DateUpdated == nil {
			break
		}

		return e.complexity.Dataset.DateUpdated(childComplexity), true

	case "Dataset.delete":
		if e.complexity.Dataset.Delete == nil {
			break
		}

		return e.complexity.Dataset.Delete(childComplexity), true

	case "Dataset.deleteTags":
		if e.complexity.Dataset.DeleteTags == nil {
			break
		}

		args, err := ec.field_Dataset_deleteTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Dataset.DeleteTags(childComplexity, args["tags"].([]string)), true

	case "Dataset.description":
		if e.complexity.Dataset.Description == nil {
			break
		}

		return e.complexity.Dataset.Description(childComplexity), true

	case "Dataset.id":
		if e.complexity.Dataset.Id == nil {
			break
		}

		return e.complexity.Dataset.Id(childComplexity), true

	case "Dataset.name":
		if e.complexity.Dataset.Name == nil {
			break
		}

		return e.complexity.Dataset.Name(childComplexity), true

	case "Dataset.owner":
		if e.complexity.Dataset.Owner == nil {
			break
		}

		return e.complexity.Dataset.Owner(childComplexity), true

	case "Dataset.tags":
		if e.complexity.Dataset.Tags == nil {
			break
		}

		return e.complexity.Dataset.Tags(childComplexity), true

	case "Dataset.visibility":
		if e.complexity.Dataset.Visibility == nil {
			break
		}

		return e.complexity.Dataset.Visibility(childComplexity), true

	case "DatasetVersion.addTags":
		if e.complexity.DatasetVersion.AddTags == nil {
			break
		}

		args, err := ec.field_DatasetVersion_addTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetVersion.AddTags(childComplexity, args["tags"].([]string)), true

	case "DatasetVersion.attributes":
		if e.complexity.DatasetVersion.Attributes == nil {
			break
		}

		return e.complexity.DatasetVersion.Attributes(childComplexity), true

	case "DatasetVersion.blobInfo":
		if e.complexity.DatasetVersion.BlobInfo == nil {
			break
		}

		return e.complexity.DatasetVersion.BlobInfo(childComplexity), true

	case "DatasetVersion.changeDescription":
		if e.complexity.DatasetVersion.ChangeDescription == nil {
			break
		}

		args, err := ec.field_DatasetVersion_changeDescription_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetVersion.ChangeDescription(childComplexity, args["description"].(string)), true

	case "DatasetVersion.dataset":
		if e.complexity.DatasetVersion.Dataset == nil {
			break
		}

		return e.complexity.DatasetVersion.Dataset(childComplexity), true

	case "DatasetVersion.datasetID":
		if e.complexity.DatasetVersion.DatasetId == nil {
			break
		}

		return e.complexity.DatasetVersion.DatasetId(childComplexity), true

	case "DatasetVersion.dateCreated":
		if e.complexity.DatasetVersion.DateCreated == nil {
			break
		}

		return e.complexity.DatasetVersion.DateCreated(childComplexity), true

	case "DatasetVersion.dateUpdated":
		if e.complexity.DatasetVersion.DateUpdated == nil {
			break
		}

		return e.complexity.DatasetVersion.DateUpdated(childComplexity), true

	case "DatasetVersion.delete":
		if e.complexity.DatasetVersion.Delete == nil {
			break
		}

		return e.complexity.DatasetVersion.Delete(childComplexity), true

	case "DatasetVersion.deleteTags":
		if e.complexity.DatasetVersion.DeleteTags == nil {
			break
		}

		args, err := ec.field_DatasetVersion_deleteTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetVersion.DeleteTags(childComplexity, args["tags"].([]string)), true

	case "DatasetVersion.description":
		if e.complexity.DatasetVersion.Description == nil {
			break
		}

		return e.complexity.DatasetVersion.Description(childComplexity), true

	case "DatasetVersion.downloadUrl":
		if e.complexity.DatasetVersion.DownloadURL == nil {
			break
		}

		args, err := ec.field_DatasetVersion_downloadUrl_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetVersion.DownloadURL(childComplexity, args["blobPath"].(string)), true

	case "DatasetVersion.id":
		if e.complexity.DatasetVersion.Id == nil {
			break
		}

		return e.complexity.DatasetVersion.Id(childComplexity), true

	case "DatasetVersion.owner":
		if e.complexity.DatasetVersion.Owner == nil {
			break
		}

		return e.complexity.DatasetVersion.Owner(childComplexity), true

	case "DatasetVersion.parentID":
		if e.complexity.DatasetVersion.ParentId == nil {
			break
		}

		return e.complexity.DatasetVersion.ParentId(childComplexity), true

	case "DatasetVersion.pathInfo":
		if e.complexity.DatasetVersion.PathInfo == nil {
			break
		}

		return e.complexity.DatasetVersion.PathInfo(childComplexity), true

	case "DatasetVersion.queryInfo":
		if e.complexity.DatasetVersion.QueryInfo == nil {
			break
		}

		return e.complexity.DatasetVersion.QueryInfo(childComplexity), true

	case "DatasetVersion.rawInfo":
		if e.complexity.DatasetVersion.RawInfo == nil {
			break
		}

		return e.complexity.DatasetVersion.RawInfo(childComplexity), true

	case "DatasetVersion.runs":
		if e.complexity.DatasetVersion.Runs == nil {
			break
		}

		args, err := ec.field_DatasetVersion_runs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.DatasetVersion.Runs(childComplexity, args["query"].(*ExperimentRunsQuery)), true

	case "DatasetVersion.tags":
		if e.complexity.DatasetVersion.Tags == nil {
			break
		}

		return e.complexity.DatasetVersion.Tags(childComplexity), true

	case "DatasetVersion.version":
		if e.complexity.DatasetVersion.Version == nil {
			break
		}

		return e.complexity.DatasetVersion.Version(childComplexity), true

	case "DatasetVersions.datasetVersions":
		if e.complexity.DatasetVersions.DatasetVersions == nil {
			break
		}

		return e.complexity.DatasetVersions.DatasetVersions(childComplexity), true

	case "DatasetVersions.total":
		if e.complexity.DatasetVersions.Total == nil {
			break
		}

		return e.complexity.DatasetVersions.Total(childComplexity), true

	case "Datasets.datasets":
		if e.complexity.Datasets.Datasets == nil {
			break
		}

		return e.complexity.Datasets.Datasets(childComplexity), true

	case "Datasets.total":
		if e.complexity.Datasets.Total == nil {
			break
		}

		return e.complexity.Datasets.Total(childComplexity), true

	case "Experiment.attributes":
		if e.complexity.Experiment.Attributes == nil {
			break
		}

		return e.complexity.Experiment.Attributes(childComplexity), true

	case "Experiment.dateCreated":
		if e.complexity.Experiment.DateCreated == nil {
			break
		}

		return e.complexity.Experiment.DateCreated(childComplexity), true

	case "Experiment.dateUpdated":
		if e.complexity.Experiment.DateUpdated == nil {
			break
		}

		return e.complexity.Experiment.DateUpdated(childComplexity), true

	case "Experiment.description":
		if e.complexity.Experiment.Description == nil {
			break
		}

		return e.complexity.Experiment.Description(childComplexity), true

	case "Experiment.id":
		if e.complexity.Experiment.Id == nil {
			break
		}

		return e.complexity.Experiment.Id(childComplexity), true

	case "Experiment.name":
		if e.complexity.Experiment.Name == nil {
			break
		}

		return e.complexity.Experiment.Name(childComplexity), true

	case "Experiment.owner":
		if e.complexity.Experiment.Owner == nil {
			break
		}

		return e.complexity.Experiment.Owner(childComplexity), true

	case "Experiment.project":
		if e.complexity.Experiment.Project == nil {
			break
		}

		return e.complexity.Experiment.Project(childComplexity), true

	case "Experiment.projectId":
		if e.complexity.Experiment.ProjectId == nil {
			break
		}

		return e.complexity.Experiment.ProjectId(childComplexity), true

	case "Experiment.runs":
		if e.complexity.Experiment.Runs == nil {
			break
		}

		args, err := ec.field_Experiment_runs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Experiment.Runs(childComplexity, args["next"].(*string), args["query"].(*ExperimentRunsQuery)), true

	case "Experiment.tags":
		if e.complexity.Experiment.Tags == nil {
			break
		}

		return e.complexity.Experiment.Tags(childComplexity), true

	case "ExperimentRun.artifacts":
		if e.complexity.ExperimentRun.Artifacts == nil {
			break
		}

		return e.complexity.ExperimentRun.Artifacts(childComplexity), true

	case "ExperimentRun.attributes":
		if e.complexity.ExperimentRun.Attributes == nil {
			break
		}

		return e.complexity.ExperimentRun.Attributes(childComplexity), true

	case "ExperimentRun.codeVersion":
		if e.complexity.ExperimentRun.CodeVersion == nil {
			break
		}

		return e.complexity.ExperimentRun.CodeVersion(childComplexity), true

	case "ExperimentRun.datasets":
		if e.complexity.ExperimentRun.Datasets == nil {
			break
		}

		return e.complexity.ExperimentRun.Datasets(childComplexity), true

	case "ExperimentRun.dateCreated":
		if e.complexity.ExperimentRun.DateCreated == nil {
			break
		}

		return e.complexity.ExperimentRun.DateCreated(childComplexity), true

	case "ExperimentRun.dateUpdated":
		if e.complexity.ExperimentRun.DateUpdated == nil {
			break
		}

		return e.complexity.ExperimentRun.DateUpdated(childComplexity), true

	case "ExperimentRun.description":
		if e.complexity.ExperimentRun.Description == nil {
			break
		}

		return e.complexity.ExperimentRun.Description(childComplexity), true

	case "ExperimentRun.experiment":
		if e.complexity.ExperimentRun.Experiment == nil {
			break
		}

		return e.complexity.ExperimentRun.Experiment(childComplexity), true

	case "ExperimentRun.experimentId":
		if e.complexity.ExperimentRun.ExperimentId == nil {
			break
		}

		return e.complexity.ExperimentRun.ExperimentId(childComplexity), true

	case "ExperimentRun.features":
		if e.complexity.ExperimentRun.Features == nil {
			break
		}

		return e.complexity.ExperimentRun.Features(childComplexity), true

	case "ExperimentRun.hyperparameters":
		if e.complexity.ExperimentRun.Hyperparameters == nil {
			break
		}

		return e.complexity.ExperimentRun.Hyperparameters(childComplexity), true

	case "ExperimentRun.id":
		if e.complexity.ExperimentRun.Id == nil {
			break
		}

		return e.complexity.ExperimentRun.Id(childComplexity), true

	case "ExperimentRun.jobId":
		if e.complexity.ExperimentRun.JobId == nil {
			break
		}

		return e.complexity.ExperimentRun.JobId(childComplexity), true

	case "ExperimentRun.metrics":
		if e.complexity.ExperimentRun.Metrics == nil {
			break
		}

		return e.complexity.ExperimentRun.Metrics(childComplexity), true

	case "ExperimentRun.name":
		if e.complexity.ExperimentRun.Name == nil {
			break
		}

		return e.complexity.ExperimentRun.Name(childComplexity), true

	case "ExperimentRun.observations":
		if e.complexity.ExperimentRun.Observations == nil {
			break
		}

		return e.complexity.ExperimentRun.Observations(childComplexity), true

	case "ExperimentRun.owner":
		if e.complexity.ExperimentRun.Owner == nil {
			break
		}

		return e.complexity.ExperimentRun.Owner(childComplexity), true

	case "ExperimentRun.project":
		if e.complexity.ExperimentRun.Project == nil {
			break
		}

		return e.complexity.ExperimentRun.Project(childComplexity), true

	case "ExperimentRun.projectId":
		if e.complexity.ExperimentRun.ProjectId == nil {
			break
		}

		return e.complexity.ExperimentRun.ProjectId(childComplexity), true

	case "ExperimentRun.tags":
		if e.complexity.ExperimentRun.Tags == nil {
			break
		}

		return e.complexity.ExperimentRun.Tags(childComplexity), true

	case "ExperimentRuns.next":
		if e.complexity.ExperimentRuns.Next == nil {
			break
		}

		return e.complexity.ExperimentRuns.Next(childComplexity), true

	case "ExperimentRuns.pagination":
		if e.complexity.ExperimentRuns.Pagination == nil {
			break
		}

		return e.complexity.ExperimentRuns.Pagination(childComplexity), true

	case "ExperimentRuns.runs":
		if e.complexity.ExperimentRuns.Runs == nil {
			break
		}

		return e.complexity.ExperimentRuns.Runs(childComplexity), true

	case "Experiments.experiments":
		if e.complexity.Experiments.Experiments == nil {
			break
		}

		return e.complexity.Experiments.Experiments(childComplexity), true

	case "Experiments.next":
		if e.complexity.Experiments.Next == nil {
			break
		}

		return e.complexity.Experiments.Next(childComplexity), true

	case "Feature.name":
		if e.complexity.Feature.Name == nil {
			break
		}

		return e.complexity.Feature.Name(childComplexity), true

	case "FloatKeyValue.key":
		if e.complexity.FloatKeyValue.Key == nil {
			break
		}

		return e.complexity.FloatKeyValue.Key(childComplexity), true

	case "FloatKeyValue.value":
		if e.complexity.FloatKeyValue.Value == nil {
			break
		}

		return e.complexity.FloatKeyValue.Value(childComplexity), true

	case "MergeResult.commit":
		if e.complexity.MergeResult.Commit == nil {
			break
		}

		return e.complexity.MergeResult.Commit(childComplexity), true

	case "MergeResult.commonBase":
		if e.complexity.MergeResult.CommonBase == nil {
			break
		}

		return e.complexity.MergeResult.CommonBase(childComplexity), true

	case "MergeResult.conflicts":
		if e.complexity.MergeResult.Conflicts == nil {
			break
		}

		return e.complexity.MergeResult.Conflicts(childComplexity), true

	case "Mutation.addProjectTag":
		if e.complexity.Mutation.AddProjectTag == nil {
			break
		}

		args, err := ec.field_Mutation_addProjectTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProjectTag(childComplexity, args["id"].(string), args["tag"].(string)), true

	case "Mutation.addRunTag":
		if e.complexity.Mutation.AddRunTag == nil {
			break
		}

		args, err := ec.field_Mutation_addRunTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRunTag(childComplexity, args["id"].(string), args["tag"].(string)), true

	case "Mutation.dataset":
		if e.complexity.Mutation.Dataset == nil {
			break
		}

		args, err := ec.field_Mutation_dataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Dataset(childComplexity, args["id"].(string)), true

	case "Mutation.delCollaboratorProject":
		if e.complexity.Mutation.DelCollaboratorProject == nil {
			break
		}

		args, err := ec.field_Mutation_delCollaboratorProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelCollaboratorProject(childComplexity, args["projid"].(string), args["collid"].(string)), true

	case "Mutation.delProject":
		if e.complexity.Mutation.DelProject == nil {
			break
		}

		args, err := ec.field_Mutation_delProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelProject(childComplexity, args["id"].(string)), true

	case "Mutation.delProjectTag":
		if e.complexity.Mutation.DelProjectTag == nil {
			break
		}

		args, err := ec.field_Mutation_delProjectTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelProjectTag(childComplexity, args["id"].(string), args["tag"].(string)), true

	case "Mutation.delRunTag":
		if e.complexity.Mutation.DelRunTag == nil {
			break
		}

		args, err := ec.field_Mutation_delRunTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelRunTag(childComplexity, args["id"].(string), args["tag"].(string)), true

	case "Mutation.editProjectDescription":
		if e.complexity.Mutation.EditProjectDescription == nil {
			break
		}

		args, err := ec.field_Mutation_editProjectDescription_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditProjectDescription(childComplexity, args["id"].(string), args["description"].(string)), true

	case "Mutation.editProjectReadme":
		if e.complexity.Mutation.EditProjectReadme == nil {
			break
		}

		args, err := ec.field_Mutation_editProjectReadme_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditProjectReadme(childComplexity, args["id"].(string), args["readme"].(string)), true

	case "Mutation.editRunDescription":
		if e.complexity.Mutation.EditRunDescription == nil {
			break
		}

		args, err := ec.field_Mutation_editRunDescription_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditRunDescription(childComplexity, args["id"].(string), args["description"].(string)), true

	case "Mutation.repository":
		if e.complexity.Mutation.Repository == nil {
			break
		}

		args, err := ec.field_Mutation_repository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Repository(childComplexity, args["id"].(string)), true

	case "Mutation.setCollaboratorProject":
		if e.complexity.Mutation.SetCollaboratorProject == nil {
			break
		}

		args, err := ec.field_Mutation_setCollaboratorProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetCollaboratorProject(childComplexity, args["projid"].(string), args["email"].(string), args["type"].(AccessType)), true

	case "Mutation.workspace":
		if e.complexity.Mutation.Workspace == nil {
			break
		}

		args, err := ec.field_Mutation_workspace_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Workspace(childComplexity, args["name"].(*string)), true

	case "NamedCommitBlob.content":
		if e.complexity.NamedCommitBlob.Content == nil {
			break
		}

		return e.complexity.NamedCommitBlob.Content(childComplexity), true

	case "NamedCommitBlob.name":
		if e.complexity.NamedCommitBlob.Name == nil {
			break
		}

		return e.complexity.NamedCommitBlob.Name(childComplexity), true

	case "NamedCommitFolder.content":
		if e.complexity.NamedCommitFolder.Content == nil {
			break
		}

		return e.complexity.NamedCommitFolder.Content(childComplexity), true

	case "NamedCommitFolder.name":
		if e.complexity.NamedCommitFolder.Name == nil {
			break
		}

		return e.complexity.NamedCommitFolder.Name(childComplexity), true

	case "NetworkBranchColor.branch":
		if e.complexity.NetworkBranchColor.Branch == nil {
			break
		}

		return e.complexity.NetworkBranchColor.Branch(childComplexity), true

	case "NetworkBranchColor.color":
		if e.complexity.NetworkBranchColor.Color == nil {
			break
		}

		return e.complexity.NetworkBranchColor.Color(childComplexity), true

	case "NetworkBranchColor.commitIndex":
		if e.complexity.NetworkBranchColor.CommitIndex == nil {
			break
		}

		return e.complexity.NetworkBranchColor.CommitIndex(childComplexity), true

	case "NetworkCommitColor.color":
		if e.complexity.NetworkCommitColor.Color == nil {
			break
		}

		return e.complexity.NetworkCommitColor.Color(childComplexity), true

	case "NetworkCommitColor.commit":
		if e.complexity.NetworkCommitColor.Commit == nil {
			break
		}

		return e.complexity.NetworkCommitColor.Commit(childComplexity), true

	case "NetworkEdgeColor.color":
		if e.complexity.NetworkEdgeColor.Color == nil {
			break
		}

		return e.complexity.NetworkEdgeColor.Color(childComplexity), true

	case "NetworkEdgeColor.edgeType":
		if e.complexity.NetworkEdgeColor.EdgeType == nil {
			break
		}

		return e.complexity.NetworkEdgeColor.EdgeType(childComplexity), true

	case "NetworkEdgeColor.fromCommitIndex":
		if e.complexity.NetworkEdgeColor.FromCommitIndex == nil {
			break
		}

		return e.complexity.NetworkEdgeColor.FromCommitIndex(childComplexity), true

	case "NetworkEdgeColor.toCommitIndex":
		if e.complexity.NetworkEdgeColor.ToCommitIndex == nil {
			break
		}

		return e.complexity.NetworkEdgeColor.ToCommitIndex(childComplexity), true

	case "Observation.artifact":
		if e.complexity.Observation.Artifact == nil {
			break
		}

		return e.complexity.Observation.Artifact(childComplexity), true

	case "Observation.attribute":
		if e.complexity.Observation.Attribute == nil {
			break
		}

		return e.complexity.Observation.Attribute(childComplexity), true

	case "Observation.timestamp":
		if e.complexity.Observation.Timestamp == nil {
			break
		}

		return e.complexity.Observation.Timestamp(childComplexity), true

	case "Organization.dateCreated":
		if e.complexity.Organization.DateCreated == nil {
			break
		}

		return e.complexity.Organization.DateCreated(childComplexity), true

	case "Organization.dateUpdated":
		if e.complexity.Organization.DateUpdated == nil {
			break
		}

		return e.complexity.Organization.DateUpdated(childComplexity), true

	case "Organization.description":
		if e.complexity.Organization.Description == nil {
			break
		}

		return e.complexity.Organization.Description(childComplexity), true

	case "Organization.id":
		if e.complexity.Organization.Id == nil {
			break
		}

		return e.complexity.Organization.Id(childComplexity), true

	case "Organization.name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Organization.owner":
		if e.complexity.Organization.Owner == nil {
			break
		}

		return e.complexity.Organization.Owner(childComplexity), true

	case "Organization.shortName":
		if e.complexity.Organization.ShortName == nil {
			break
		}

		return e.complexity.Organization.ShortName(childComplexity), true

	case "Organization.teams":
		if e.complexity.Organization.Teams == nil {
			break
		}

		return e.complexity.Organization.Teams(childComplexity), true

	case "PaginationResponse.limit":
		if e.complexity.PaginationResponse.Limit == nil {
			break
		}

		return e.complexity.PaginationResponse.Limit(childComplexity), true

	case "PaginationResponse.page":
		if e.complexity.PaginationResponse.Page == nil {
			break
		}

		return e.complexity.PaginationResponse.Page(childComplexity), true

	case "PaginationResponse.totalRecords":
		if e.complexity.PaginationResponse.TotalRecords == nil {
			break
		}

		return e.complexity.PaginationResponse.TotalRecords(childComplexity), true

	case "Project.access":
		if e.complexity.Project.Access == nil {
			break
		}

		return e.complexity.Project.Access(childComplexity), true

	case "Project.attributes":
		if e.complexity.Project.Attributes == nil {
			break
		}

		return e.complexity.Project.Attributes(childComplexity), true

	case "Project.collaborators":
		if e.complexity.Project.Collaborators == nil {
			break
		}

		return e.complexity.Project.Collaborators(childComplexity), true

	case "Project.dateCreated":
		if e.complexity.Project.DateCreated == nil {
			break
		}

		return e.complexity.Project.DateCreated(childComplexity), true

	case "Project.dateUpdated":
		if e.complexity.Project.DateUpdated == nil {
			break
		}

		return e.complexity.Project.DateUpdated(childComplexity), true

	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true

	case "Project.experiments":
		if e.complexity.Project.Experiments == nil {
			break
		}

		args, err := ec.field_Project_experiments_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Experiments(childComplexity, args["next"].(*string), args["query"].(*ExperimentsQuery)), true

	case "Project.id":
		if e.complexity.Project.Id == nil {
			break
		}

		return e.complexity.Project.Id(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.owner":
		if e.complexity.Project.Owner == nil {
			break
		}

		return e.complexity.Project.Owner(childComplexity), true

	case "Project.projectVisibility":
		if e.complexity.Project.ProjectVisibility == nil {
			break
		}

		return e.complexity.Project.ProjectVisibility(childComplexity), true

	case "Project.readmeText":
		if e.complexity.Project.ReadmeText == nil {
			break
		}

		return e.complexity.Project.ReadmeText(childComplexity), true

	case "Project.runs":
		if e.complexity.Project.Runs == nil {
			break
		}

		args, err := ec.field_Project_runs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Runs(childComplexity, args["next"].(*string), args["query"].(*ExperimentRunsQuery)), true

	case "Project.shortName":
		if e.complexity.Project.ShortName == nil {
			break
		}

		return e.complexity.Project.ShortName(childComplexity), true

	case "Project.tags":
		if e.complexity.Project.Tags == nil {
			break
		}

		return e.complexity.Project.Tags(childComplexity), true

	case "Projects.next":
		if e.complexity.Projects.Next == nil {
			break
		}

		return e.complexity.Projects.Next(childComplexity), true

	case "Projects.projects":
		if e.complexity.Projects.Projects == nil {
			break
		}

		return e.complexity.Projects.Projects(childComplexity), true

	case "Query.dataset":
		if e.complexity.Query.Dataset == nil {
			break
		}

		args, err := ec.field_Query_dataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Dataset(childComplexity, args["id"].(string)), true

	case "Query.experiment":
		if e.complexity.Query.Experiment == nil {
			break
		}

		args, err := ec.field_Query_experiment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Experiment(childComplexity, args["id"].(string)), true

	case "Query.organization":
		if e.complexity.Query.Organization == nil {
			break
		}

		args, err := ec.field_Query_organization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Organization(childComplexity, args["id"].(string)), true

	case "Query.organizations":
		if e.complexity.Query.Organizations == nil {
			break
		}

		return e.complexity.Query.Organizations(childComplexity), true

	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		args, err := ec.field_Query_project_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Project(childComplexity, args["id"].(string)), true

	case "Query.repository":
		if e.complexity.Query.Repository == nil {
			break
		}

		args, err := ec.field_Query_repository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Repository(childComplexity, args["id"].(string)), true

	case "Query.run":
		if e.complexity.Query.Run == nil {
			break
		}

		args, err := ec.field_Query_run_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Run(childComplexity, args["id"].(string)), true

	case "Query.self":
		if e.complexity.Query.Self == nil {
			break
		}

		return e.complexity.Query.Self(childComplexity), true

	case "Query.teams":
		if e.complexity.Query.Teams == nil {
			break
		}

		return e.complexity.Query.Teams(childComplexity), true

	case "Query.workspace":
		if e.complexity.Query.Workspace == nil {
			break
		}

		args, err := ec.field_Query_workspace_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Workspace(childComplexity, args["name"].(*string)), true

	case "Repositories.next":
		if e.complexity.Repositories.Next == nil {
			break
		}

		return e.complexity.Repositories.Next(childComplexity), true

	case "Repositories.pagination":
		if e.complexity.Repositories.Pagination == nil {
			break
		}

		return e.complexity.Repositories.Pagination(childComplexity), true

	case "Repositories.repositories":
		if e.complexity.Repositories.Repositories == nil {
			break
		}

		return e.complexity.Repositories.Repositories(childComplexity), true

	case "Repository.addLabels":
		if e.complexity.Repository.AddLabels == nil {
			break
		}

		args, err := ec.field_Repository_addLabels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.AddLabels(childComplexity, args["labels"].([]string)), true

	case "Repository.allowedActions":
		if e.complexity.Repository.AllowedActions == nil {
			break
		}

		return e.complexity.Repository.AllowedActions(childComplexity), true

	case "Repository.branch":
		if e.complexity.Repository.Branch == nil {
			break
		}

		args, err := ec.field_Repository_branch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Branch(childComplexity, args["name"].(string)), true

	case "Repository.branches":
		if e.complexity.Repository.Branches == nil {
			break
		}

		return e.complexity.Repository.Branches(childComplexity), true

	case "Repository.collaborators":
		if e.complexity.Repository.Collaborators == nil {
			break
		}

		return e.complexity.Repository.Collaborators(childComplexity), true

	case "Repository.commit":
		if e.complexity.Repository.Commit == nil {
			break
		}

		args, err := ec.field_Repository_commit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Commit(childComplexity, args["id"].(string)), true

	case "Repository.commitByReference":
		if e.complexity.Repository.CommitByReference == nil {
			break
		}

		args, err := ec.field_Repository_commitByReference_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.CommitByReference(childComplexity, args["ref"].(CommitReference)), true

	case "Repository.dateCreated":
		if e.complexity.Repository.DateCreated == nil {
			break
		}

		return e.complexity.Repository.DateCreated(childComplexity), true

	case "Repository.dateUpdated":
		if e.complexity.Repository.DateUpdated == nil {
			break
		}

		return e.complexity.Repository.DateUpdated(childComplexity), true

	case "Repository.delete":
		if e.complexity.Repository.Delete == nil {
			break
		}

		return e.complexity.Repository.Delete(childComplexity), true

	case "Repository.deleteLabels":
		if e.complexity.Repository.DeleteLabels == nil {
			break
		}

		args, err := ec.field_Repository_deleteLabels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.DeleteLabels(childComplexity, args["labels"].([]string)), true

	case "Repository.diff":
		if e.complexity.Repository.Diff == nil {
			break
		}

		args, err := ec.field_Repository_diff_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Diff(childComplexity, args["a"].(CommitReference), args["b"].(CommitReference)), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.labels":
		if e.complexity.Repository.Labels == nil {
			break
		}

		return e.complexity.Repository.Labels(childComplexity), true

	case "Repository.log":
		if e.complexity.Repository.Log == nil {
			break
		}

		args, err := ec.field_Repository_log_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Log(childComplexity, args["commit"].(CommitReference)), true

	case "Repository.merge":
		if e.complexity.Repository.Merge == nil {
			break
		}

		args, err := ec.field_Repository_merge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Merge(childComplexity, args["a"].(CommitReference), args["b"].(CommitReference), args["message"].(*string), args["isDryRun"].(*bool)), true

	case "Repository.name":
		if e.complexity.Repository.Name == nil {
			break
		}

		return e.complexity.Repository.Name(childComplexity), true

	case "Repository.network":
		if e.complexity.Repository.Network == nil {
			break
		}

		return e.complexity.Repository.Network(childComplexity), true

	case "Repository.owner":
		if e.complexity.Repository.Owner == nil {
			break
		}

		return e.complexity.Repository.Owner(childComplexity), true

	case "Repository.tag":
		if e.complexity.Repository.Tag == nil {
			break
		}

		args, err := ec.field_Repository_tag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Repository.Tag(childComplexity, args["name"].(string)), true

	case "Repository.tags":
		if e.complexity.Repository.Tags == nil {
			break
		}

		return e.complexity.Repository.Tags(childComplexity), true

	case "RepositoryBranch.commit":
		if e.complexity.RepositoryBranch.Commit == nil {
			break
		}

		return e.complexity.RepositoryBranch.Commit(childComplexity), true

	case "RepositoryBranch.name":
		if e.complexity.RepositoryBranch.Name == nil {
			break
		}

		return e.complexity.RepositoryBranch.Name(childComplexity), true

	case "RepositoryTag.commit":
		if e.complexity.RepositoryTag.Commit == nil {
			break
		}

		return e.complexity.RepositoryTag.Commit(childComplexity), true

	case "RepositoryTag.name":
		if e.complexity.RepositoryTag.Name == nil {
			break
		}

		return e.complexity.RepositoryTag.Name(childComplexity), true

	case "StringKeyValue.key":
		if e.complexity.StringKeyValue.Key == nil {
			break
		}

		return e.complexity.StringKeyValue.Key(childComplexity), true

	case "StringKeyValue.value":
		if e.complexity.StringKeyValue.Value == nil {
			break
		}

		return e.complexity.StringKeyValue.Value(childComplexity), true

	case "Team.dateCreated":
		if e.complexity.Team.DateCreated == nil {
			break
		}

		return e.complexity.Team.DateCreated(childComplexity), true

	case "Team.dateUpdated":
		if e.complexity.Team.DateUpdated == nil {
			break
		}

		return e.complexity.Team.DateUpdated(childComplexity), true

	case "Team.description":
		if e.complexity.Team.Description == nil {
			break
		}

		return e.complexity.Team.Description(childComplexity), true

	case "Team.id":
		if e.complexity.Team.Id == nil {
			break
		}

		return e.complexity.Team.Id(childComplexity), true

	case "Team.name":
		if e.complexity.Team.Name == nil {
			break
		}

		return e.complexity.Team.Name(childComplexity), true

	case "Team.organization":
		if e.complexity.Team.Organization == nil {
			break
		}

		return e.complexity.Team.Organization(childComplexity), true

	case "Team.organizationId":
		if e.complexity.Team.OrganizationID == nil {
			break
		}

		return e.complexity.Team.OrganizationID(childComplexity), true

	case "Team.owner":
		if e.complexity.Team.Owner == nil {
			break
		}

		return e.complexity.Team.Owner(childComplexity), true

	case "Team.shortName":
		if e.complexity.Team.ShortName == nil {
			break
		}

		return e.complexity.Team.ShortName(childComplexity), true

	case "TeamCollaborator.canDeploy":
		if e.complexity.TeamCollaborator.CanDeploy == nil {
			break
		}

		return e.complexity.TeamCollaborator.CanDeploy(childComplexity), true

	case "TeamCollaborator.team":
		if e.complexity.TeamCollaborator.Team == nil {
			break
		}

		return e.complexity.TeamCollaborator.Team(childComplexity), true

	case "TeamCollaborator.type":
		if e.complexity.TeamCollaborator.Type == nil {
			break
		}

		return e.complexity.TeamCollaborator.Type(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.picture":
		if e.complexity.User.Picture == nil {
			break
		}

		return e.complexity.User.Picture(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserCollaborator.canDeploy":
		if e.complexity.UserCollaborator.CanDeploy == nil {
			break
		}

		return e.complexity.UserCollaborator.CanDeploy(childComplexity), true

	case "UserCollaborator.type":
		if e.complexity.UserCollaborator.Type == nil {
			break
		}

		return e.complexity.UserCollaborator.Type(childComplexity), true

	case "UserCollaborator.user":
		if e.complexity.UserCollaborator.User == nil {
			break
		}

		return e.complexity.UserCollaborator.User(childComplexity), true

	case "Workspace.createDataset":
		if e.complexity.Workspace.CreateDataset == nil {
			break
		}

		args, err := ec.field_Workspace_createDataset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Workspace.CreateDataset(childComplexity, args["name"].(string), args["visibility"].(Visibility)), true

	case "Workspace.createRepository":
		if e.complexity.Workspace.CreateRepository == nil {
			break
		}

		args, err := ec.field_Workspace_createRepository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Workspace.CreateRepository(childComplexity, args["name"].(string), args["visibility"].(Visibility)), true

	case "Workspace.datasetVersions":
		if e.complexity.Workspace.DatasetVersions == nil {
			break
		}

		args, err := ec.field_Workspace_datasetVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Workspace.DatasetVersions(childComplexity, args["query"].(*DatasetVersionsQuery)), true

	case "Workspace.datasets":
		if e.complexity.Workspace.Datasets == nil {
			break
		}

		args, err := ec.field_Workspace_datasets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Workspace.Datasets(childComplexity, args["query"].(*DatasetsQuery)), true

	case "Workspace.name":
		if e.complexity.Workspace.Name == nil {
			break
		}

		return e.complexity.Workspace.Name(childComplexity), true

	case "Workspace.projects":
		if e.complexity.Workspace.Projects == nil {
			break
		}

		args, err := ec.field_Workspace_projects_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Workspace.Projects(childComplexity, args["next"].(*string), args["query"].(*ProjectsQuery)), true

	case "Workspace.repositories":
		if e.complexity.Workspace.Repositories == nil {
			break
		}

		args, err := ec.field_Workspace_repositories_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Workspace.Repositories(childComplexity, args["next"].(*string), args["query"].(*RepositoriesQuery)), true

	case "Workspace.repository":
		if e.complexity.Workspace.Repository == nil {
			break
		}

		args, err := ec.field_Workspace_repository_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Workspace.Repository(childComplexity, args["name"].(string)), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `type AllowedActions {
    create: Boolean!
    update: Boolean!
    delete: Boolean!
    deploy: Boolean!
}
enum ArtifactType {
  IMAGE
  MODEL
  TENSORBOARD
  DATA
  BLOB
  STRING
}

type Artifact {
  key: String!
  path: String!
  type: ArtifactType!
  pathOnly: Boolean!
}
type NetworkBranchColor {
  branch: String!
  color: Int!
  commitIndex: Int!
}

type NetworkCommitColor {
  commit: Commit!
  color: Int!
}

enum NetworkEdgeType {
  DEFAULT
  BRANCH
  MERGE
}

type NetworkEdgeColor {
  fromCommitIndex: Int!
  toCommitIndex: Int!
  color: Int!
  edgeType: NetworkEdgeType!
}

type BranchesNetwork {
  branches: [NetworkBranchColor!]!
  commits: [NetworkCommitColor!]!
  edges: [NetworkEdgeColor!]!
}
enum AccessType {
  OWNER
  READ_ONLY
  READ_WRITE
}

type UserCollaborator {
  user: User!
  type: AccessType!
  canDeploy: Boolean!
}

type TeamCollaborator {
  team: Team!
  type: AccessType!
  canDeploy: Boolean!
}

union Collaborator = UserCollaborator | TeamCollaborator

input CollaboratorReference {
  usernameOrEmail: String
  teamID: String
}
type Commit {
  id: String!
  message: String!
  date: Date!
  author: User!

  getLocation(location: [String!]!): CommitElement
  asDiff: CommitAsDiff

  runs(query: ExperimentRunsQuery): ExperimentRuns!

  setTag(name: String!): Repository!
  setBranch(name: String!): Repository!
}

type Commits {
  # TODO: pagination
  commits: [Commit!]!
}

type CommitAsDiff {
  parent: String!
  diff: [String!]
}

union CommitElement = CommitFolder | CommitBlob

type NamedCommitFolder {
  name: String!
  content: CommitFolder!
}

type NamedCommitBlob {
  name: String!
  content: CommitBlob!
}

type CommitFolder {
  subfolders: [NamedCommitFolder!]!
  blobs: [NamedCommitBlob!]!
}

type CommitBlob {
  content: String!
  runs(query: ExperimentRunsQuery): ExperimentRuns!
  downloadUrlForComponent(componentPath: String!): String!
}
enum DatasetVisibility {
  PRIVATE
  PUBLIC
}

type Dataset {
  id: ID!
  name: String!
  description: String!
  dateCreated: Date!
  dateUpdated: Date!
  visibility: DatasetVisibility!
  allowedActions: AllowedActions!

  attributes: [KeyValue!]!
  tags: [String!]!
  owner: User!
  collaborators: [Collaborator!]!

  addTags(tags: [String!]!): Dataset!
  deleteTags(tags: [String!]!): Dataset!

  datasetVersions(query: DatasetVersionsQuery): DatasetVersions!
  changeDescription(description: String!): Dataset!
  delete: Boolean!
}

type Datasets {
  datasets: [Dataset!]!
  total: Int!
}

input DatasetsQuery {
  pagination: PaginationQuery
  stringPredicates: [StringPredicate!]
  floatPredicates: [FloatPredicate!]
  ids: [ID!]
}
type DatasetVersion {
  id: ID!
  parentID: ID! # TODO: remove?
  datasetID: ID!
  dataset: Dataset!

  description: String!
  dateCreated: Date!
  dateUpdated: Date!
  attributes: [KeyValue!]!
  owner: User!
  version: Int!

  downloadUrl(blobPath: String!): String

  tags: [String!]!
  addTags(tags: [String!]!): DatasetVersion!
  deleteTags(tags: [String!]!): DatasetVersion!

  runs(query: ExperimentRunsQuery): ExperimentRuns!

  blobInfo: String # serialized dataset blob
  # Don't bother defining types for old info types as they'll be deleted laters
  rawInfo: String
  pathInfo: String
  queryInfo: String

  changeDescription(description: String!): DatasetVersion!
  delete: Boolean!
}

type DatasetVersions {
  datasetVersions: [DatasetVersion!]!
  total: Int!
}

input DatasetVersionsQuery {
  pagination: PaginationQuery
  stringPredicates: [StringPredicate!]
  floatPredicates: [FloatPredicate!]
  ids: [ID!]
}
type Experiment {
  id: ID!
  projectId: String!
  project: Project!
  name: String!
  description: String!
  dateCreated: Date!
  dateUpdated: Date!

  attributes: [KeyValue!]!
  tags: [String!]!
  owner: User!

  runs(next: String, query: ExperimentRunsQuery): ExperimentRuns!
}

type Experiments {
  experiments: [Experiment!]!
  next: String
}

input ExperimentsQuery {
  pagination: PaginationQuery
}
type Feature {
  name: String
}

type ExperimentRun {
  id: ID!
  projectId: String!
  project: Project!
  experimentId: String!
  experiment: Experiment!
  name: String!
  description: String!
  dateCreated: Date!
  dateUpdated: Date!

  attributes: [KeyValue!]!
  tags: [String!]!
  hyperparameters: [KeyValue!]!
  artifacts: [Artifact!]!
  datasets: [Artifact!]!
  metrics: [KeyValue!]!
  observations: [Observation!]!
  features: [Feature!]!
  jobId: String
  owner: User!
  codeVersion: String

}

type ExperimentRuns {
  runs: [ExperimentRun!]!
  next: String
  pagination: PaginationResponse!
}

input ExperimentRunsQuery {
  pagination: PaginationQuery
}
union KeyValue = StringKeyValue | FloatKeyValue

type StringKeyValue {
  key: String!
  value: String!
}

type FloatKeyValue {
  key: String!
  value: Float!
}
type Mutation {
  editRunDescription(id: ID!, description: String!): ExperimentRun
  addRunTag(id: ID!, tag: String!): ExperimentRun
  delRunTag(id: ID!, tag: String!): ExperimentRun

  setCollaboratorProject(projid: ID!, email: String!, type: AccessType!): Project
  delCollaboratorProject(projid: ID!, collid: ID!): Project

  editProjectDescription(id: ID!, description: String!): Project
  editProjectReadme(id: ID!, readme: String!): Project
  addProjectTag(id: ID!, tag: String!): Project
  delProjectTag(id: ID!, tag: String!): Project
  delProject(id: ID!): Boolean!

  dataset(id: ID!): Dataset

  repository(id: ID!): Repository
  workspace(name: String): Workspace
}
type Observation {
  attribute: KeyValue
  artifact: Artifact
  timestamp: Date
}
type Organization {
    id: ID!
    name: String!
    shortName: String!
    description: String!
    owner: User!
    dateCreated: Date!
    dateUpdated: Date!

    teams: [Team!]!
}
enum ProjectVisibility {
  PRIVATE
  PUBLIC
}

type Project {
  id: ID!
  name: String!
  description: String!
  dateCreated: Date!
  dateUpdated: Date!
  shortName: String!
  readmeText: String!
  projectVisibility: ProjectVisibility!
  access: AccessType!

  attributes: [KeyValue!]!
  tags: [String!]!
  owner: User!
  collaborators: [Collaborator!]!

  experiments(next: String, query: ExperimentsQuery): Experiments!
  runs(next: String, query: ExperimentRunsQuery): ExperimentRuns!
}

type Projects {
  projects: [Project!]!
  next: String
}

input ProjectsQuery {
  pagination: PaginationQuery
}
type Query {
  organizations: [Organization!]!
  teams: [Team!]!
  self: User

  project(id: ID!): Project
  experiment(id: ID!): Experiment
  run(id: ID!): ExperimentRun
  dataset(id: ID!): Dataset
  repository(id: ID!): Repository
  organization(id: ID!): Organization

  workspace(name: String): Workspace
}

input PaginationQuery {
  page: Int
  limit: Int
}

type PaginationResponse {
  page: Int!
  limit: Int!
  totalRecords: Int!
}

input StringPredicate {
  key: String!
  value: String!
  operator: PredicateOperator!
}

input FloatPredicate {
  key: String!
  value: Float!
  operator: PredicateOperator!
}

enum PredicateOperator {
  EQ
  NE
  GT
  GTE
  LT
  LTE
  CONTAIN
  NOT_CONTAIN
  IN
}
type Repository {
    id: ID!
    name: String!
    dateCreated: Date!
    dateUpdated: Date!

    labels: [String!]!
    owner: User!
    collaborators: [Collaborator!]!
    allowedActions: AllowedActions!

    tags: [RepositoryTag!]!
    branches: [RepositoryBranch!]!

    commit(id: ID!): Commit
    tag(name: String!): Commit
    branch(name: String!): Commit
    commitByReference(ref: CommitReference!): Commit

    diff(a: CommitReference!, b: CommitReference!): [String!]
    log(commit: CommitReference!): Commits!

    network: BranchesNetwork!

    delete: Boolean!
    addLabels(labels: [String!]!): Repository!
    deleteLabels(labels: [String!]!): Repository!
    merge(a: CommitReference!, b: CommitReference!, message: String, isDryRun: Boolean): MergeResult!
}

input CommitReference {
  commit: ID
  tag: String
  branch: String
}

type Repositories {
  repositories: [Repository!]!
  next: String
  pagination: PaginationResponse!
}

input RepositoriesQuery {
  pagination: PaginationQuery
  stringPredicates: [StringPredicate!]
  floatPredicates: [FloatPredicate!]
  ids: [Int!]
}

type RepositoryTag {
  name: String!
  commit: Commit!
}

type RepositoryBranch {
  name: String!
  commit: Commit!
}

type MergeResult {
  commit: Commit
  commonBase: Commit
  conflicts: [String!]
}
scalar Date
type Team {
    id: ID!
    organizationId: String!
    organization: Organization!
    name: String!
    shortName: String!
    description: String!
    owner: User!
    dateCreated: Date!
    dateUpdated: Date!
}
type User {
  id: ID!
  name: String
  email: String!
  picture: String
  roles: [String!]!
  username: String!
}
enum Visibility {
  PRIVATE
  PUBLIC
  ORG_SCOPED_PUBLIC
}
type Workspace {
  name: String!

  projects(next: String, query: ProjectsQuery): Projects!

  datasets(query: DatasetsQuery): Datasets!
  datasetVersions(query: DatasetVersionsQuery): DatasetVersions!
  createDataset(name: String!, visibility: Visibility!): Dataset!

  repositories(next: String, query: RepositoriesQuery): Repositories!
  repository(name: String!): Repository
  createRepository(name: String!, visibility: Visibility!): Repository!


  # not sure this is needed now or later, but this feels like it where go


}
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_CommitBlob_downloadUrlForComponent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["componentPath"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["componentPath"] = arg0
	return args, nil
}

func (ec *executionContext) field_CommitBlob_runs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ExperimentRunsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg0, err = ec.unmarshalOExperimentRunsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRunsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Commit_getLocation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["location"]; ok {
		arg0, err = ec.unmarshalNString2ᚕstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["location"] = arg0
	return args, nil
}

func (ec *executionContext) field_Commit_runs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ExperimentRunsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg0, err = ec.unmarshalOExperimentRunsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRunsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Commit_setBranch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Commit_setTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetVersion_addTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["tags"]; ok {
		arg0, err = ec.unmarshalNString2ᚕstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tags"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetVersion_changeDescription_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["description"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetVersion_deleteTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["tags"]; ok {
		arg0, err = ec.unmarshalNString2ᚕstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tags"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetVersion_downloadUrl_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["blobPath"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["blobPath"] = arg0
	return args, nil
}

func (ec *executionContext) field_DatasetVersion_runs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *ExperimentRunsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg0, err = ec.unmarshalOExperimentRunsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRunsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Dataset_addTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["tags"]; ok {
		arg0, err = ec.unmarshalNString2ᚕstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tags"] = arg0
	return args, nil
}

func (ec *executionContext) field_Dataset_changeDescription_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["description"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg0
	return args, nil
}

func (ec *executionContext) field_Dataset_datasetVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DatasetVersionsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg0, err = ec.unmarshalODatasetVersionsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersionsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Dataset_deleteTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["tags"]; ok {
		arg0, err = ec.unmarshalNString2ᚕstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tags"] = arg0
	return args, nil
}

func (ec *executionContext) field_Experiment_runs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["next"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg0
	var arg1 *ExperimentRunsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg1, err = ec.unmarshalOExperimentRunsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRunsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addProjectTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["tag"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tag"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_addRunTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["tag"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tag"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_dataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_delCollaboratorProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projid"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projid"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["collid"]; ok {
		arg1, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["collid"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_delProjectTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["tag"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tag"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_delProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_delRunTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["tag"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tag"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_editProjectDescription_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["description"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_editProjectReadme_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["readme"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["readme"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_editRunDescription_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["description"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_repository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setCollaboratorProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projid"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projid"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["email"]; ok {
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg1
	var arg2 AccessType
	if tmp, ok := rawArgs["type"]; ok {
		arg2, err = ec.unmarshalNAccessType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAccessType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["type"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_workspace_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Project_experiments_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["next"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg0
	var arg1 *ExperimentsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg1, err = ec.unmarshalOExperimentsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg1
	return args, nil
}

func (ec *executionContext) field_Project_runs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["next"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg0
	var arg1 *ExperimentRunsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg1, err = ec.unmarshalOExperimentRunsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRunsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_dataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_experiment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_organization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_project_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_repository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_run_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_workspace_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Repository_addLabels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["labels"]; ok {
		arg0, err = ec.unmarshalNString2ᚕstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg0
	return args, nil
}

func (ec *executionContext) field_Repository_branch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Repository_commitByReference_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CommitReference
	if tmp, ok := rawArgs["ref"]; ok {
		arg0, err = ec.unmarshalNCommitReference2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitReference(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ref"] = arg0
	return args, nil
}

func (ec *executionContext) field_Repository_commit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Repository_deleteLabels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["labels"]; ok {
		arg0, err = ec.unmarshalNString2ᚕstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["labels"] = arg0
	return args, nil
}

func (ec *executionContext) field_Repository_diff_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CommitReference
	if tmp, ok := rawArgs["a"]; ok {
		arg0, err = ec.unmarshalNCommitReference2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitReference(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["a"] = arg0
	var arg1 CommitReference
	if tmp, ok := rawArgs["b"]; ok {
		arg1, err = ec.unmarshalNCommitReference2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitReference(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["b"] = arg1
	return args, nil
}

func (ec *executionContext) field_Repository_log_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CommitReference
	if tmp, ok := rawArgs["commit"]; ok {
		arg0, err = ec.unmarshalNCommitReference2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitReference(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["commit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Repository_merge_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CommitReference
	if tmp, ok := rawArgs["a"]; ok {
		arg0, err = ec.unmarshalNCommitReference2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitReference(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["a"] = arg0
	var arg1 CommitReference
	if tmp, ok := rawArgs["b"]; ok {
		arg1, err = ec.unmarshalNCommitReference2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitReference(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["b"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["message"]; ok {
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["message"] = arg2
	var arg3 *bool
	if tmp, ok := rawArgs["isDryRun"]; ok {
		arg3, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["isDryRun"] = arg3
	return args, nil
}

func (ec *executionContext) field_Repository_tag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Workspace_createDataset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 Visibility
	if tmp, ok := rawArgs["visibility"]; ok {
		arg1, err = ec.unmarshalNVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐVisibility(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["visibility"] = arg1
	return args, nil
}

func (ec *executionContext) field_Workspace_createRepository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 Visibility
	if tmp, ok := rawArgs["visibility"]; ok {
		arg1, err = ec.unmarshalNVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐVisibility(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["visibility"] = arg1
	return args, nil
}

func (ec *executionContext) field_Workspace_datasetVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DatasetVersionsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg0, err = ec.unmarshalODatasetVersionsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersionsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Workspace_datasets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *DatasetsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg0, err = ec.unmarshalODatasetsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Workspace_projects_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["next"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg0
	var arg1 *ProjectsQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg1, err = ec.unmarshalOProjectsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjectsQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg1
	return args, nil
}

func (ec *executionContext) field_Workspace_repositories_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["next"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg0
	var arg1 *RepositoriesQuery
	if tmp, ok := rawArgs["query"]; ok {
		arg1, err = ec.unmarshalORepositoriesQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐRepositoriesQuery(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg1
	return args, nil
}

func (ec *executionContext) field_Workspace_repository_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AllowedActions_create(ctx context.Context, field graphql.CollectedField, obj *AllowedActions) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AllowedActions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Create, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AllowedActions_update(ctx context.Context, field graphql.CollectedField, obj *AllowedActions) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AllowedActions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Update, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AllowedActions_delete(ctx context.Context, field graphql.CollectedField, obj *AllowedActions) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AllowedActions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AllowedActions_deploy(ctx context.Context, field graphql.CollectedField, obj *AllowedActions) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AllowedActions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deploy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Artifact_key(ctx context.Context, field graphql.CollectedField, obj *common.Artifact) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Artifact",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Artifact_path(ctx context.Context, field graphql.CollectedField, obj *common.Artifact) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Artifact",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Artifact_type(ctx context.Context, field graphql.CollectedField, obj *common.Artifact) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Artifact",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Artifact().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ArtifactType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNArtifactType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐArtifactType(ctx, field.Selections, res)
}

func (ec *executionContext) _Artifact_pathOnly(ctx context.Context, field graphql.CollectedField, obj *common.Artifact) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Artifact",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _BranchesNetwork_branches(ctx context.Context, field graphql.CollectedField, obj *BranchesNetwork) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BranchesNetwork",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*NetworkBranchColor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNetworkBranchColor2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkBranchColor(ctx, field.Selections, res)
}

func (ec *executionContext) _BranchesNetwork_commits(ctx context.Context, field graphql.CollectedField, obj *BranchesNetwork) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BranchesNetwork",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.NetworkCommitColor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNetworkCommitColor2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNetworkCommitColor(ctx, field.Selections, res)
}

func (ec *executionContext) _BranchesNetwork_edges(ctx context.Context, field graphql.CollectedField, obj *BranchesNetwork) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BranchesNetwork",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*NetworkEdgeColor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNetworkEdgeColor2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkEdgeColor(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_id(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_message(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().Message(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_date(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().Date(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_author(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().Author(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_getLocation(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Commit_getLocation_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().GetLocation(rctx, obj, args["location"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(CommitElement)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCommitElement2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitElement(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_asDiff(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().AsDiff(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CommitAsDiff)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCommitAsDiff2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitAsDiff(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_runs(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Commit_runs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().Runs(rctx, obj, args["query"].(*ExperimentRunsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ExperimentRuns)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperimentRuns2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRuns(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_setTag(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Commit_setTag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().SetTag(rctx, obj, args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Commit_setBranch(ctx context.Context, field graphql.CollectedField, obj *models.Commit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Commit_setBranch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Commit().SetBranch(rctx, obj, args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _CommitAsDiff_parent(ctx context.Context, field graphql.CollectedField, obj *CommitAsDiff) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CommitAsDiff",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CommitAsDiff_diff(ctx context.Context, field graphql.CollectedField, obj *CommitAsDiff) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CommitAsDiff",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Diff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CommitBlob_content(ctx context.Context, field graphql.CollectedField, obj *models.CommitBlob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CommitBlob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CommitBlob_runs(ctx context.Context, field graphql.CollectedField, obj *models.CommitBlob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CommitBlob",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CommitBlob_runs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CommitBlob().Runs(rctx, obj, args["query"].(*ExperimentRunsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ExperimentRuns)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperimentRuns2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRuns(ctx, field.Selections, res)
}

func (ec *executionContext) _CommitBlob_downloadUrlForComponent(ctx context.Context, field graphql.CollectedField, obj *models.CommitBlob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CommitBlob",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_CommitBlob_downloadUrlForComponent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CommitBlob().DownloadURLForComponent(rctx, obj, args["componentPath"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CommitFolder_subfolders(ctx context.Context, field graphql.CollectedField, obj *CommitFolder) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CommitFolder",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subfolders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.NamedCommitFolder)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNamedCommitFolder2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitFolder(ctx, field.Selections, res)
}

func (ec *executionContext) _CommitFolder_blobs(ctx context.Context, field graphql.CollectedField, obj *CommitFolder) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CommitFolder",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Blobs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.NamedCommitBlob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNamedCommitBlob2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitBlob(ctx, field.Selections, res)
}

func (ec *executionContext) _Commits_commits(ctx context.Context, field graphql.CollectedField, obj *Commits) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Commits",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCommit2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_id(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_name(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_description(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_dateCreated(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().DateCreated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_dateUpdated(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().DateUpdated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_visibility(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().Visibility(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DatasetVisibility)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDatasetVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVisibility(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_allowedActions(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().AllowedActions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*AllowedActions)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAllowedActions2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAllowedActions(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_attributes(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().Attributes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]KeyValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNKeyValue2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_tags(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_owner(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_collaborators(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().Collaborators(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Collaborator)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCollaborator2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCollaborator(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_addTags(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Dataset_addTags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().AddTags(rctx, obj, args["tags"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.Dataset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_deleteTags(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Dataset_deleteTags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().DeleteTags(rctx, obj, args["tags"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.Dataset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_datasetVersions(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Dataset_datasetVersions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().DatasetVersions(rctx, obj, args["query"].(*DatasetVersionsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DatasetVersions)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDatasetVersions2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersions(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_changeDescription(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Dataset_changeDescription_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().ChangeDescription(rctx, obj, args["description"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.Dataset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) _Dataset_delete(ctx context.Context, field graphql.CollectedField, obj *modeldb.Dataset) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Dataset",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Dataset().Delete(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_id(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_parentID(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_datasetID(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DatasetId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_dataset(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().Dataset(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.Dataset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_description(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_dateCreated(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().DateCreated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_dateUpdated(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().DateUpdated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_attributes(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().Attributes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]KeyValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNKeyValue2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_owner(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_version(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().Version(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_downloadUrl(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DatasetVersion_downloadUrl_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().DownloadURL(rctx, obj, args["blobPath"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_tags(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_addTags(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DatasetVersion_addTags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().AddTags(rctx, obj, args["tags"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.DatasetVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDatasetVersion2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDatasetVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_deleteTags(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DatasetVersion_deleteTags_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().DeleteTags(rctx, obj, args["tags"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.DatasetVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDatasetVersion2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDatasetVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_runs(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DatasetVersion_runs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().Runs(rctx, obj, args["query"].(*ExperimentRunsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ExperimentRuns)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperimentRuns2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRuns(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_blobInfo(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().BlobInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_rawInfo(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().RawInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_pathInfo(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().PathInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_queryInfo(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().QueryInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_changeDescription(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_DatasetVersion_changeDescription_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().ChangeDescription(rctx, obj, args["description"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.DatasetVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDatasetVersion2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDatasetVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersion_delete(ctx context.Context, field graphql.CollectedField, obj *modeldb.DatasetVersion) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersion",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DatasetVersion().Delete(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersions_datasetVersions(ctx context.Context, field graphql.CollectedField, obj *DatasetVersions) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DatasetVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*modeldb.DatasetVersion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDatasetVersion2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDatasetVersion(ctx, field.Selections, res)
}

func (ec *executionContext) _DatasetVersions_total(ctx context.Context, field graphql.CollectedField, obj *DatasetVersions) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "DatasetVersions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Datasets_datasets(ctx context.Context, field graphql.CollectedField, obj *Datasets) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Datasets",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Datasets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*modeldb.Dataset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDataset2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) _Datasets_total(ctx context.Context, field graphql.CollectedField, obj *Datasets) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Datasets",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_id(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_projectId(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_project(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Experiment().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_name(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_description(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_dateCreated(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Experiment().DateCreated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_dateUpdated(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Experiment().DateUpdated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_attributes(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Experiment().Attributes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]KeyValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNKeyValue2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_tags(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_owner(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Experiment().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiment_runs(ctx context.Context, field graphql.CollectedField, obj *modeldb.Experiment) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiment",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Experiment_runs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Experiment().Runs(rctx, obj, args["next"].(*string), args["query"].(*ExperimentRunsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ExperimentRuns)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperimentRuns2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRuns(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_id(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_projectId(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_project(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ExperimentRun().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experimentId(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExperimentId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_experiment(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ExperimentRun().Experiment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.Experiment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperiment2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_name(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_description(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_dateCreated(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ExperimentRun().DateCreated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_dateUpdated(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ExperimentRun().DateUpdated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_attributes(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ExperimentRun().Attributes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]KeyValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNKeyValue2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_tags(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_hyperparameters(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ExperimentRun().Hyperparameters(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]KeyValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNKeyValue2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_artifacts(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artifacts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*common.Artifact)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNArtifact2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_datasets(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Datasets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*common.Artifact)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNArtifact2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_metrics(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ExperimentRun().Metrics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]KeyValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNKeyValue2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_observations(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Observations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*modeldb.Observation)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNObservation2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐObservation(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_features(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Features, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*modeldb.Feature)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFeature2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐFeature(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_jobId(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_owner(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ExperimentRun().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRun_codeVersion(ctx context.Context, field graphql.CollectedField, obj *modeldb.ExperimentRun) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRun",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CodeVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRuns_runs(ctx context.Context, field graphql.CollectedField, obj *ExperimentRuns) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRuns",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Runs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*modeldb.ExperimentRun)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperimentRun2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRuns_next(ctx context.Context, field graphql.CollectedField, obj *ExperimentRuns) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRuns",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Next, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ExperimentRuns_pagination(ctx context.Context, field graphql.CollectedField, obj *ExperimentRuns) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ExperimentRuns",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginationResponse)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPaginationResponse2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_experiments(ctx context.Context, field graphql.CollectedField, obj *Experiments) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Experiments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*modeldb.Experiment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperiment2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx, field.Selections, res)
}

func (ec *executionContext) _Experiments_next(ctx context.Context, field graphql.CollectedField, obj *Experiments) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Experiments",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Next, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Feature_name(ctx context.Context, field graphql.CollectedField, obj *modeldb.Feature) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Feature",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FloatKeyValue_key(ctx context.Context, field graphql.CollectedField, obj *FloatKeyValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "FloatKeyValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _FloatKeyValue_value(ctx context.Context, field graphql.CollectedField, obj *FloatKeyValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "FloatKeyValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _MergeResult_commit(ctx context.Context, field graphql.CollectedField, obj *MergeResult) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MergeResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _MergeResult_commonBase(ctx context.Context, field graphql.CollectedField, obj *MergeResult) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MergeResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommonBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _MergeResult_conflicts(ctx context.Context, field graphql.CollectedField, obj *MergeResult) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MergeResult",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_editRunDescription(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_editRunDescription_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditRunDescription(rctx, args["id"].(string), args["description"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.ExperimentRun)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOExperimentRun2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addRunTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addRunTag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddRunTag(rctx, args["id"].(string), args["tag"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.ExperimentRun)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOExperimentRun2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_delRunTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_delRunTag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DelRunTag(rctx, args["id"].(string), args["tag"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.ExperimentRun)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOExperimentRun2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_setCollaboratorProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_setCollaboratorProject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetCollaboratorProject(rctx, args["projid"].(string), args["email"].(string), args["type"].(AccessType))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_delCollaboratorProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_delCollaboratorProject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DelCollaboratorProject(rctx, args["projid"].(string), args["collid"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_editProjectDescription(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_editProjectDescription_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditProjectDescription(rctx, args["id"].(string), args["description"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_editProjectReadme(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_editProjectReadme_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditProjectReadme(rctx, args["id"].(string), args["readme"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_addProjectTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_addProjectTag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddProjectTag(rctx, args["id"].(string), args["tag"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_delProjectTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_delProjectTag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DelProjectTag(rctx, args["id"].(string), args["tag"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_delProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_delProject_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DelProject(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_dataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_dataset_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Dataset(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Dataset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_repository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_repository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Repository(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalORepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_workspace(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_workspace_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Workspace(rctx, args["name"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Workspace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOWorkspace2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐWorkspace(ctx, field.Selections, res)
}

func (ec *executionContext) _NamedCommitBlob_name(ctx context.Context, field graphql.CollectedField, obj *models.NamedCommitBlob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NamedCommitBlob",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NamedCommitBlob_content(ctx context.Context, field graphql.CollectedField, obj *models.NamedCommitBlob) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NamedCommitBlob",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.NamedCommitBlob().Content(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.CommitBlob)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCommitBlob2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommitBlob(ctx, field.Selections, res)
}

func (ec *executionContext) _NamedCommitFolder_name(ctx context.Context, field graphql.CollectedField, obj *models.NamedCommitFolder) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NamedCommitFolder",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NamedCommitFolder_content(ctx context.Context, field graphql.CollectedField, obj *models.NamedCommitFolder) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NamedCommitFolder",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.NamedCommitFolder().Content(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*CommitFolder)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCommitFolder2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitFolder(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkBranchColor_branch(ctx context.Context, field graphql.CollectedField, obj *NetworkBranchColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkBranchColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkBranchColor_color(ctx context.Context, field graphql.CollectedField, obj *NetworkBranchColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkBranchColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkBranchColor_commitIndex(ctx context.Context, field graphql.CollectedField, obj *NetworkBranchColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkBranchColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkCommitColor_commit(ctx context.Context, field graphql.CollectedField, obj *models.NetworkCommitColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkCommitColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkCommitColor_color(ctx context.Context, field graphql.CollectedField, obj *models.NetworkCommitColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkCommitColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkEdgeColor_fromCommitIndex(ctx context.Context, field graphql.CollectedField, obj *NetworkEdgeColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkEdgeColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromCommitIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkEdgeColor_toCommitIndex(ctx context.Context, field graphql.CollectedField, obj *NetworkEdgeColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkEdgeColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToCommitIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkEdgeColor_color(ctx context.Context, field graphql.CollectedField, obj *NetworkEdgeColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkEdgeColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _NetworkEdgeColor_edgeType(ctx context.Context, field graphql.CollectedField, obj *NetworkEdgeColor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "NetworkEdgeColor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EdgeType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(NetworkEdgeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNNetworkEdgeType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkEdgeType(ctx, field.Selections, res)
}

func (ec *executionContext) _Observation_attribute(ctx context.Context, field graphql.CollectedField, obj *modeldb.Observation) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Observation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Observation().Attribute(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(KeyValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOKeyValue2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _Observation_artifact(ctx context.Context, field graphql.CollectedField, obj *modeldb.Observation) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Observation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Observation().Artifact(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*common.Artifact)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOArtifact2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx, field.Selections, res)
}

func (ec *executionContext) _Observation_timestamp(ctx context.Context, field graphql.CollectedField, obj *modeldb.Observation) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Observation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Observation().Timestamp(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_id(ctx context.Context, field graphql.CollectedField, obj *uac.Organization) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *uac.Organization) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_shortName(ctx context.Context, field graphql.CollectedField, obj *uac.Organization) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_description(ctx context.Context, field graphql.CollectedField, obj *uac.Organization) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_owner(ctx context.Context, field graphql.CollectedField, obj *uac.Organization) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_dateCreated(ctx context.Context, field graphql.CollectedField, obj *uac.Organization) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().DateCreated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_dateUpdated(ctx context.Context, field graphql.CollectedField, obj *uac.Organization) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().DateUpdated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Organization_teams(ctx context.Context, field graphql.CollectedField, obj *uac.Organization) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Organization",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().Teams(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*uac.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeam2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _PaginationResponse_page(ctx context.Context, field graphql.CollectedField, obj *PaginationResponse) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PaginationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Page, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _PaginationResponse_limit(ctx context.Context, field graphql.CollectedField, obj *PaginationResponse) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PaginationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _PaginationResponse_totalRecords(ctx context.Context, field graphql.CollectedField, obj *PaginationResponse) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PaginationResponse",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRecords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_id(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_name(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_description(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_dateCreated(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().DateCreated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_dateUpdated(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().DateUpdated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_shortName(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_readmeText(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadmeText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_projectVisibility(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().ProjectVisibility(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ProjectVisibility)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNProjectVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjectVisibility(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_access(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Access(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AccessType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAccessType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAccessType(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_attributes(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Attributes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]KeyValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNKeyValue2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_tags(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_owner(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_collaborators(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Collaborators(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Collaborator)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCollaborator2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCollaborator(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_experiments(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Project_experiments_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Experiments(rctx, obj, args["next"].(*string), args["query"].(*ExperimentsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Experiments)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperiments2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperiments(ctx, field.Selections, res)
}

func (ec *executionContext) _Project_runs(ctx context.Context, field graphql.CollectedField, obj *modeldb.Project) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Project",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Project_runs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Runs(rctx, obj, args["next"].(*string), args["query"].(*ExperimentRunsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ExperimentRuns)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExperimentRuns2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRuns(ctx, field.Selections, res)
}

func (ec *executionContext) _Projects_projects(ctx context.Context, field graphql.CollectedField, obj *Projects) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Projects",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNProject2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Projects_next(ctx context.Context, field graphql.CollectedField, obj *Projects) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Projects",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Next, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_organizations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Organizations(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*uac.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOrganization2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_teams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Teams(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*uac.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeam2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_self(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Self(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_project(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_project_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Project(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Project)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_experiment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_experiment_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Experiment(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Experiment)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOExperiment2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_run(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_run_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Run(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.ExperimentRun)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOExperimentRun2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_dataset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_dataset_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Dataset(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*modeldb.Dataset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_repository(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_repository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Repository(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalORepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_organization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_organization_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Organization(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uac.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOrganization2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_workspace(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_workspace_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Workspace(rctx, args["name"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Workspace)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOWorkspace2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐWorkspace(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Repositories_repositories(ctx context.Context, field graphql.CollectedField, obj *Repositories) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repositories",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepository2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Repositories_next(ctx context.Context, field graphql.CollectedField, obj *Repositories) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repositories",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Next, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Repositories_pagination(ctx context.Context, field graphql.CollectedField, obj *Repositories) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repositories",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PaginationResponse)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPaginationResponse2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_name(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_dateCreated(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().DateCreated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_dateUpdated(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().DateUpdated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_labels(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Labels(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_owner(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_collaborators(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Collaborators(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]Collaborator)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCollaborator2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCollaborator(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_allowedActions(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().AllowedActions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*AllowedActions)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAllowedActions2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAllowedActions(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_tags(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.RepositoryTag)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepositoryTag2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryTag(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_branches(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Branches(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.RepositoryBranch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepositoryBranch2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryBranch(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_commit(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_commit_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Commit(rctx, obj, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_tag(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_tag_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Tag(rctx, obj, args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_branch(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_branch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Branch(rctx, obj, args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_commitByReference(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_commitByReference_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().CommitByReference(rctx, obj, args["ref"].(CommitReference))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_diff(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_diff_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Diff(rctx, obj, args["a"].(CommitReference), args["b"].(CommitReference))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_log(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_log_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Log(rctx, obj, args["commit"].(CommitReference))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Commits)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCommits2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommits(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_network(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Network(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BranchesNetwork)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBranchesNetwork2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐBranchesNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_delete(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Delete(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_addLabels(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_addLabels_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().AddLabels(rctx, obj, args["labels"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_deleteLabels(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_deleteLabels_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().DeleteLabels(rctx, obj, args["labels"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Repository_merge(ctx context.Context, field graphql.CollectedField, obj *versioning.Repository) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Repository",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Repository_merge_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().Merge(rctx, obj, args["a"].(CommitReference), args["b"].(CommitReference), args["message"].(*string), args["isDryRun"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*MergeResult)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMergeResult2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐMergeResult(ctx, field.Selections, res)
}

func (ec *executionContext) _RepositoryBranch_name(ctx context.Context, field graphql.CollectedField, obj *models.RepositoryBranch) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "RepositoryBranch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepositoryBranch_commit(ctx context.Context, field graphql.CollectedField, obj *models.RepositoryBranch) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "RepositoryBranch",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepositoryBranch().Commit(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _RepositoryTag_name(ctx context.Context, field graphql.CollectedField, obj *models.RepositoryTag) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "RepositoryTag",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RepositoryTag_commit(ctx context.Context, field graphql.CollectedField, obj *models.RepositoryTag) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "RepositoryTag",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepositoryTag().Commit(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Commit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, field.Selections, res)
}

func (ec *executionContext) _StringKeyValue_key(ctx context.Context, field graphql.CollectedField, obj *StringKeyValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StringKeyValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StringKeyValue_value(ctx context.Context, field graphql.CollectedField, obj *StringKeyValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "StringKeyValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_id(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_organizationId(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().OrganizationID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_organization(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Organization(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.Organization)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOrganization2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_name(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_shortName(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_description(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_owner(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().Owner(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_dateCreated(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().DateCreated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Team_dateUpdated(ctx context.Context, field graphql.CollectedField, obj *uac.Team) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Team",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().DateUpdated(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamCollaborator_team(ctx context.Context, field graphql.CollectedField, obj *models.TeamCollaborator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamCollaborator",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamCollaborator().Team(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.Team)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeam2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamCollaborator_type(ctx context.Context, field graphql.CollectedField, obj *models.TeamCollaborator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamCollaborator",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamCollaborator().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AccessType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAccessType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAccessType(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamCollaborator_canDeploy(ctx context.Context, field graphql.CollectedField, obj *models.TeamCollaborator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamCollaborator",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TeamCollaborator().CanDeploy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *uac.UserInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *uac.UserInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Name(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *uac.UserInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_picture(ctx context.Context, field graphql.CollectedField, obj *uac.UserInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Picture(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *uac.UserInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *uac.UserInfo) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Username(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _UserCollaborator_user(ctx context.Context, field graphql.CollectedField, obj *models.UserCollaborator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserCollaborator",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserCollaborator().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*uac.UserInfo)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _UserCollaborator_type(ctx context.Context, field graphql.CollectedField, obj *models.UserCollaborator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserCollaborator",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserCollaborator().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(AccessType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAccessType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAccessType(ctx, field.Selections, res)
}

func (ec *executionContext) _UserCollaborator_canDeploy(ctx context.Context, field graphql.CollectedField, obj *models.UserCollaborator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "UserCollaborator",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.UserCollaborator().CanDeploy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Workspace_name(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Workspace",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Workspace_projects(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Workspace",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Workspace_projects_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Workspace().Projects(rctx, obj, args["next"].(*string), args["query"].(*ProjectsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Projects)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNProjects2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjects(ctx, field.Selections, res)
}

func (ec *executionContext) _Workspace_datasets(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Workspace",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Workspace_datasets_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Workspace().Datasets(rctx, obj, args["query"].(*DatasetsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Datasets)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDatasets2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasets(ctx, field.Selections, res)
}

func (ec *executionContext) _Workspace_datasetVersions(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Workspace",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Workspace_datasetVersions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Workspace().DatasetVersions(rctx, obj, args["query"].(*DatasetVersionsQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DatasetVersions)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDatasetVersions2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersions(ctx, field.Selections, res)
}

func (ec *executionContext) _Workspace_createDataset(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Workspace",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Workspace_createDataset_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Workspace().CreateDataset(rctx, obj, args["name"].(string), args["visibility"].(Visibility))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*modeldb.Dataset)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, field.Selections, res)
}

func (ec *executionContext) _Workspace_repositories(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Workspace",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Workspace_repositories_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Workspace().Repositories(rctx, obj, args["next"].(*string), args["query"].(*RepositoriesQuery))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Repositories)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepositories2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐRepositories(ctx, field.Selections, res)
}

func (ec *executionContext) _Workspace_repository(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Workspace",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Workspace_repository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Workspace().Repository(rctx, obj, args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalORepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) _Workspace_createRepository(ctx context.Context, field graphql.CollectedField, obj *models.Workspace) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Workspace",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Workspace_createRepository_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Workspace().CreateRepository(rctx, obj, args["name"].(string), args["visibility"].(Visibility))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*versioning.Repository)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCollaboratorReference(ctx context.Context, obj interface{}) (CollaboratorReference, error) {
	var it CollaboratorReference
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "usernameOrEmail":
			var err error
			it.UsernameOrEmail, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamID":
			var err error
			it.TeamID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCommitReference(ctx context.Context, obj interface{}) (CommitReference, error) {
	var it CommitReference
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "commit":
			var err error
			it.Commit, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "tag":
			var err error
			it.Tag, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "branch":
			var err error
			it.Branch, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDatasetVersionsQuery(ctx context.Context, obj interface{}) (DatasetVersionsQuery, error) {
	var it DatasetVersionsQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPaginationQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx, v)
			if err != nil {
				return it, err
			}
		case "stringPredicates":
			var err error
			it.StringPredicates, err = ec.unmarshalOStringPredicate2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐStringPredicate(ctx, v)
			if err != nil {
				return it, err
			}
		case "floatPredicates":
			var err error
			it.FloatPredicates, err = ec.unmarshalOFloatPredicate2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐFloatPredicate(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDatasetsQuery(ctx context.Context, obj interface{}) (DatasetsQuery, error) {
	var it DatasetsQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPaginationQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx, v)
			if err != nil {
				return it, err
			}
		case "stringPredicates":
			var err error
			it.StringPredicates, err = ec.unmarshalOStringPredicate2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐStringPredicate(ctx, v)
			if err != nil {
				return it, err
			}
		case "floatPredicates":
			var err error
			it.FloatPredicates, err = ec.unmarshalOFloatPredicate2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐFloatPredicate(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentRunsQuery(ctx context.Context, obj interface{}) (ExperimentRunsQuery, error) {
	var it ExperimentRunsQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPaginationQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExperimentsQuery(ctx context.Context, obj interface{}) (ExperimentsQuery, error) {
	var it ExperimentsQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPaginationQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFloatPredicate(ctx context.Context, obj interface{}) (FloatPredicate, error) {
	var it FloatPredicate
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "key":
			var err error
			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "operator":
			var err error
			it.Operator, err = ec.unmarshalNPredicateOperator2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPredicateOperator(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPaginationQuery(ctx context.Context, obj interface{}) (PaginationQuery, error) {
	var it PaginationQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "page":
			var err error
			it.Page, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error
			it.Limit, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectsQuery(ctx context.Context, obj interface{}) (ProjectsQuery, error) {
	var it ProjectsQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPaginationQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepositoriesQuery(ctx context.Context, obj interface{}) (RepositoriesQuery, error) {
	var it RepositoriesQuery
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pagination":
			var err error
			it.Pagination, err = ec.unmarshalOPaginationQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx, v)
			if err != nil {
				return it, err
			}
		case "stringPredicates":
			var err error
			it.StringPredicates, err = ec.unmarshalOStringPredicate2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐStringPredicate(ctx, v)
			if err != nil {
				return it, err
			}
		case "floatPredicates":
			var err error
			it.FloatPredicates, err = ec.unmarshalOFloatPredicate2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐFloatPredicate(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOInt2ᚕint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringPredicate(ctx context.Context, obj interface{}) (StringPredicate, error) {
	var it StringPredicate
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "key":
			var err error
			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "operator":
			var err error
			it.Operator, err = ec.unmarshalNPredicateOperator2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPredicateOperator(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Collaborator(ctx context.Context, sel ast.SelectionSet, obj *Collaborator) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.UserCollaborator:
		return ec._UserCollaborator(ctx, sel, &obj)
	case *models.UserCollaborator:
		return ec._UserCollaborator(ctx, sel, obj)
	case models.TeamCollaborator:
		return ec._TeamCollaborator(ctx, sel, &obj)
	case *models.TeamCollaborator:
		return ec._TeamCollaborator(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _CommitElement(ctx context.Context, sel ast.SelectionSet, obj *CommitElement) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case CommitFolder:
		return ec._CommitFolder(ctx, sel, &obj)
	case *CommitFolder:
		return ec._CommitFolder(ctx, sel, obj)
	case models.CommitBlob:
		return ec._CommitBlob(ctx, sel, &obj)
	case *models.CommitBlob:
		return ec._CommitBlob(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _KeyValue(ctx context.Context, sel ast.SelectionSet, obj *KeyValue) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case StringKeyValue:
		return ec._StringKeyValue(ctx, sel, &obj)
	case *StringKeyValue:
		return ec._StringKeyValue(ctx, sel, obj)
	case FloatKeyValue:
		return ec._FloatKeyValue(ctx, sel, &obj)
	case *FloatKeyValue:
		return ec._FloatKeyValue(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var allowedActionsImplementors = []string{"AllowedActions"}

func (ec *executionContext) _AllowedActions(ctx context.Context, sel ast.SelectionSet, obj *AllowedActions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, allowedActionsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AllowedActions")
		case "create":
			out.Values[i] = ec._AllowedActions_create(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "update":
			out.Values[i] = ec._AllowedActions_update(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delete":
			out.Values[i] = ec._AllowedActions_delete(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deploy":
			out.Values[i] = ec._AllowedActions_deploy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var artifactImplementors = []string{"Artifact"}

func (ec *executionContext) _Artifact(ctx context.Context, sel ast.SelectionSet, obj *common.Artifact) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, artifactImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Artifact")
		case "key":
			out.Values[i] = ec._Artifact_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":
			out.Values[i] = ec._Artifact_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Artifact_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "pathOnly":
			out.Values[i] = ec._Artifact_pathOnly(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var branchesNetworkImplementors = []string{"BranchesNetwork"}

func (ec *executionContext) _BranchesNetwork(ctx context.Context, sel ast.SelectionSet, obj *BranchesNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, branchesNetworkImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BranchesNetwork")
		case "branches":
			out.Values[i] = ec._BranchesNetwork_branches(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "commits":
			out.Values[i] = ec._BranchesNetwork_commits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edges":
			out.Values[i] = ec._BranchesNetwork_edges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitImplementors = []string{"Commit"}

func (ec *executionContext) _Commit(ctx context.Context, sel ast.SelectionSet, obj *models.Commit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, commitImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Commit")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "message":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_message(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "date":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_date(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "author":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_author(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getLocation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_getLocation(ctx, field, obj)
				return res
			})
		case "asDiff":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_asDiff(ctx, field, obj)
				return res
			})
		case "runs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_runs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "setTag":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_setTag(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "setBranch":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Commit_setBranch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitAsDiffImplementors = []string{"CommitAsDiff"}

func (ec *executionContext) _CommitAsDiff(ctx context.Context, sel ast.SelectionSet, obj *CommitAsDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, commitAsDiffImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitAsDiff")
		case "parent":
			out.Values[i] = ec._CommitAsDiff_parent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "diff":
			out.Values[i] = ec._CommitAsDiff_diff(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitBlobImplementors = []string{"CommitBlob", "CommitElement"}

func (ec *executionContext) _CommitBlob(ctx context.Context, sel ast.SelectionSet, obj *models.CommitBlob) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, commitBlobImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitBlob")
		case "content":
			out.Values[i] = ec._CommitBlob_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "runs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CommitBlob_runs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "downloadUrlForComponent":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CommitBlob_downloadUrlForComponent(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitFolderImplementors = []string{"CommitFolder", "CommitElement"}

func (ec *executionContext) _CommitFolder(ctx context.Context, sel ast.SelectionSet, obj *CommitFolder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, commitFolderImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitFolder")
		case "subfolders":
			out.Values[i] = ec._CommitFolder_subfolders(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blobs":
			out.Values[i] = ec._CommitFolder_blobs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitsImplementors = []string{"Commits"}

func (ec *executionContext) _Commits(ctx context.Context, sel ast.SelectionSet, obj *Commits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, commitsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Commits")
		case "commits":
			out.Values[i] = ec._Commits_commits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var datasetImplementors = []string{"Dataset"}

func (ec *executionContext) _Dataset(ctx context.Context, sel ast.SelectionSet, obj *modeldb.Dataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, datasetImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dataset")
		case "id":
			out.Values[i] = ec._Dataset_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Dataset_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dateCreated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_dateCreated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateUpdated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_dateUpdated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "visibility":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_visibility(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allowedActions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_allowedActions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "attributes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_attributes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "tags":
			out.Values[i] = ec._Dataset_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "collaborators":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_collaborators(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "addTags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_addTags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "deleteTags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_deleteTags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "datasetVersions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_datasetVersions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "changeDescription":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_changeDescription(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "delete":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dataset_delete(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var datasetVersionImplementors = []string{"DatasetVersion"}

func (ec *executionContext) _DatasetVersion(ctx context.Context, sel ast.SelectionSet, obj *modeldb.DatasetVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, datasetVersionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasetVersion")
		case "id":
			out.Values[i] = ec._DatasetVersion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parentID":
			out.Values[i] = ec._DatasetVersion_parentID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "datasetID":
			out.Values[i] = ec._DatasetVersion_datasetID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dataset":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_dataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "description":
			out.Values[i] = ec._DatasetVersion_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dateCreated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_dateCreated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateUpdated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_dateUpdated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "attributes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_attributes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "version":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "downloadUrl":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_downloadUrl(ctx, field, obj)
				return res
			})
		case "tags":
			out.Values[i] = ec._DatasetVersion_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "addTags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_addTags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "deleteTags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_deleteTags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "runs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_runs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "blobInfo":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_blobInfo(ctx, field, obj)
				return res
			})
		case "rawInfo":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_rawInfo(ctx, field, obj)
				return res
			})
		case "pathInfo":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_pathInfo(ctx, field, obj)
				return res
			})
		case "queryInfo":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_queryInfo(ctx, field, obj)
				return res
			})
		case "changeDescription":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_changeDescription(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "delete":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DatasetVersion_delete(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var datasetVersionsImplementors = []string{"DatasetVersions"}

func (ec *executionContext) _DatasetVersions(ctx context.Context, sel ast.SelectionSet, obj *DatasetVersions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, datasetVersionsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatasetVersions")
		case "datasetVersions":
			out.Values[i] = ec._DatasetVersions_datasetVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "total":
			out.Values[i] = ec._DatasetVersions_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var datasetsImplementors = []string{"Datasets"}

func (ec *executionContext) _Datasets(ctx context.Context, sel ast.SelectionSet, obj *Datasets) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, datasetsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Datasets")
		case "datasets":
			out.Values[i] = ec._Datasets_datasets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "total":
			out.Values[i] = ec._Datasets_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentImplementors = []string{"Experiment"}

func (ec *executionContext) _Experiment(ctx context.Context, sel ast.SelectionSet, obj *modeldb.Experiment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, experimentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Experiment")
		case "id":
			out.Values[i] = ec._Experiment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "projectId":
			out.Values[i] = ec._Experiment_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "project":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Experiment_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			out.Values[i] = ec._Experiment_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Experiment_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dateCreated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Experiment_dateCreated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateUpdated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Experiment_dateUpdated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "attributes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Experiment_attributes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "tags":
			out.Values[i] = ec._Experiment_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Experiment_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "runs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Experiment_runs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentRunImplementors = []string{"ExperimentRun"}

func (ec *executionContext) _ExperimentRun(ctx context.Context, sel ast.SelectionSet, obj *modeldb.ExperimentRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, experimentRunImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExperimentRun")
		case "id":
			out.Values[i] = ec._ExperimentRun_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "projectId":
			out.Values[i] = ec._ExperimentRun_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "project":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExperimentRun_project(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "experimentId":
			out.Values[i] = ec._ExperimentRun_experimentId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "experiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExperimentRun_experiment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			out.Values[i] = ec._ExperimentRun_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._ExperimentRun_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dateCreated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExperimentRun_dateCreated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateUpdated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExperimentRun_dateUpdated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "attributes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExperimentRun_attributes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "tags":
			out.Values[i] = ec._ExperimentRun_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hyperparameters":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExperimentRun_hyperparameters(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "artifacts":
			out.Values[i] = ec._ExperimentRun_artifacts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "datasets":
			out.Values[i] = ec._ExperimentRun_datasets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "metrics":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExperimentRun_metrics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "observations":
			out.Values[i] = ec._ExperimentRun_observations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "features":
			out.Values[i] = ec._ExperimentRun_features(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "jobId":
			out.Values[i] = ec._ExperimentRun_jobId(ctx, field, obj)
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ExperimentRun_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "codeVersion":
			out.Values[i] = ec._ExperimentRun_codeVersion(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentRunsImplementors = []string{"ExperimentRuns"}

func (ec *executionContext) _ExperimentRuns(ctx context.Context, sel ast.SelectionSet, obj *ExperimentRuns) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, experimentRunsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExperimentRuns")
		case "runs":
			out.Values[i] = ec._ExperimentRuns_runs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "next":
			out.Values[i] = ec._ExperimentRuns_next(ctx, field, obj)
		case "pagination":
			out.Values[i] = ec._ExperimentRuns_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var experimentsImplementors = []string{"Experiments"}

func (ec *executionContext) _Experiments(ctx context.Context, sel ast.SelectionSet, obj *Experiments) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, experimentsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Experiments")
		case "experiments":
			out.Values[i] = ec._Experiments_experiments(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "next":
			out.Values[i] = ec._Experiments_next(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var featureImplementors = []string{"Feature"}

func (ec *executionContext) _Feature(ctx context.Context, sel ast.SelectionSet, obj *modeldb.Feature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, featureImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Feature")
		case "name":
			out.Values[i] = ec._Feature_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var floatKeyValueImplementors = []string{"FloatKeyValue", "KeyValue"}

func (ec *executionContext) _FloatKeyValue(ctx context.Context, sel ast.SelectionSet, obj *FloatKeyValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, floatKeyValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FloatKeyValue")
		case "key":
			out.Values[i] = ec._FloatKeyValue_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._FloatKeyValue_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mergeResultImplementors = []string{"MergeResult"}

func (ec *executionContext) _MergeResult(ctx context.Context, sel ast.SelectionSet, obj *MergeResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mergeResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MergeResult")
		case "commit":
			out.Values[i] = ec._MergeResult_commit(ctx, field, obj)
		case "commonBase":
			out.Values[i] = ec._MergeResult_commonBase(ctx, field, obj)
		case "conflicts":
			out.Values[i] = ec._MergeResult_conflicts(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "editRunDescription":
			out.Values[i] = ec._Mutation_editRunDescription(ctx, field)
		case "addRunTag":
			out.Values[i] = ec._Mutation_addRunTag(ctx, field)
		case "delRunTag":
			out.Values[i] = ec._Mutation_delRunTag(ctx, field)
		case "setCollaboratorProject":
			out.Values[i] = ec._Mutation_setCollaboratorProject(ctx, field)
		case "delCollaboratorProject":
			out.Values[i] = ec._Mutation_delCollaboratorProject(ctx, field)
		case "editProjectDescription":
			out.Values[i] = ec._Mutation_editProjectDescription(ctx, field)
		case "editProjectReadme":
			out.Values[i] = ec._Mutation_editProjectReadme(ctx, field)
		case "addProjectTag":
			out.Values[i] = ec._Mutation_addProjectTag(ctx, field)
		case "delProjectTag":
			out.Values[i] = ec._Mutation_delProjectTag(ctx, field)
		case "delProject":
			out.Values[i] = ec._Mutation_delProject(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dataset":
			out.Values[i] = ec._Mutation_dataset(ctx, field)
		case "repository":
			out.Values[i] = ec._Mutation_repository(ctx, field)
		case "workspace":
			out.Values[i] = ec._Mutation_workspace(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var namedCommitBlobImplementors = []string{"NamedCommitBlob"}

func (ec *executionContext) _NamedCommitBlob(ctx context.Context, sel ast.SelectionSet, obj *models.NamedCommitBlob) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, namedCommitBlobImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NamedCommitBlob")
		case "name":
			out.Values[i] = ec._NamedCommitBlob_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "content":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NamedCommitBlob_content(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var namedCommitFolderImplementors = []string{"NamedCommitFolder"}

func (ec *executionContext) _NamedCommitFolder(ctx context.Context, sel ast.SelectionSet, obj *models.NamedCommitFolder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, namedCommitFolderImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NamedCommitFolder")
		case "name":
			out.Values[i] = ec._NamedCommitFolder_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "content":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NamedCommitFolder_content(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkBranchColorImplementors = []string{"NetworkBranchColor"}

func (ec *executionContext) _NetworkBranchColor(ctx context.Context, sel ast.SelectionSet, obj *NetworkBranchColor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, networkBranchColorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkBranchColor")
		case "branch":
			out.Values[i] = ec._NetworkBranchColor_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "color":
			out.Values[i] = ec._NetworkBranchColor_color(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "commitIndex":
			out.Values[i] = ec._NetworkBranchColor_commitIndex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkCommitColorImplementors = []string{"NetworkCommitColor"}

func (ec *executionContext) _NetworkCommitColor(ctx context.Context, sel ast.SelectionSet, obj *models.NetworkCommitColor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, networkCommitColorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkCommitColor")
		case "commit":
			out.Values[i] = ec._NetworkCommitColor_commit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "color":
			out.Values[i] = ec._NetworkCommitColor_color(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkEdgeColorImplementors = []string{"NetworkEdgeColor"}

func (ec *executionContext) _NetworkEdgeColor(ctx context.Context, sel ast.SelectionSet, obj *NetworkEdgeColor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, networkEdgeColorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NetworkEdgeColor")
		case "fromCommitIndex":
			out.Values[i] = ec._NetworkEdgeColor_fromCommitIndex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "toCommitIndex":
			out.Values[i] = ec._NetworkEdgeColor_toCommitIndex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "color":
			out.Values[i] = ec._NetworkEdgeColor_color(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edgeType":
			out.Values[i] = ec._NetworkEdgeColor_edgeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var observationImplementors = []string{"Observation"}

func (ec *executionContext) _Observation(ctx context.Context, sel ast.SelectionSet, obj *modeldb.Observation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, observationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Observation")
		case "attribute":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Observation_attribute(ctx, field, obj)
				return res
			})
		case "artifact":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Observation_artifact(ctx, field, obj)
				return res
			})
		case "timestamp":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Observation_timestamp(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var organizationImplementors = []string{"Organization"}

func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *uac.Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, organizationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "id":
			out.Values[i] = ec._Organization_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Organization_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "shortName":
			out.Values[i] = ec._Organization_shortName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Organization_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateCreated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_dateCreated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateUpdated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_dateUpdated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "teams":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_teams(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var paginationResponseImplementors = []string{"PaginationResponse"}

func (ec *executionContext) _PaginationResponse(ctx context.Context, sel ast.SelectionSet, obj *PaginationResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, paginationResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PaginationResponse")
		case "page":
			out.Values[i] = ec._PaginationResponse_page(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "limit":
			out.Values[i] = ec._PaginationResponse_limit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalRecords":
			out.Values[i] = ec._PaginationResponse_totalRecords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectImplementors = []string{"Project"}

func (ec *executionContext) _Project(ctx context.Context, sel ast.SelectionSet, obj *modeldb.Project) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, projectImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Project")
		case "id":
			out.Values[i] = ec._Project_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Project_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Project_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dateCreated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_dateCreated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateUpdated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_dateUpdated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "shortName":
			out.Values[i] = ec._Project_shortName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "readmeText":
			out.Values[i] = ec._Project_readmeText(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "projectVisibility":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_projectVisibility(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "access":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_access(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "attributes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_attributes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "tags":
			out.Values[i] = ec._Project_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "collaborators":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_collaborators(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "experiments":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_experiments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "runs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_runs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectsImplementors = []string{"Projects"}

func (ec *executionContext) _Projects(ctx context.Context, sel ast.SelectionSet, obj *Projects) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, projectsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Projects")
		case "projects":
			out.Values[i] = ec._Projects_projects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "next":
			out.Values[i] = ec._Projects_next(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "organizations":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organizations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "teams":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_teams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "self":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_self(ctx, field)
				return res
			})
		case "project":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_project(ctx, field)
				return res
			})
		case "experiment":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_experiment(ctx, field)
				return res
			})
		case "run":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_run(ctx, field)
				return res
			})
		case "dataset":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dataset(ctx, field)
				return res
			})
		case "repository":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repository(ctx, field)
				return res
			})
		case "organization":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_organization(ctx, field)
				return res
			})
		case "workspace":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_workspace(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoriesImplementors = []string{"Repositories"}

func (ec *executionContext) _Repositories(ctx context.Context, sel ast.SelectionSet, obj *Repositories) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, repositoriesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repositories")
		case "repositories":
			out.Values[i] = ec._Repositories_repositories(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "next":
			out.Values[i] = ec._Repositories_next(ctx, field, obj)
		case "pagination":
			out.Values[i] = ec._Repositories_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryImplementors = []string{"Repository"}

func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *versioning.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, repositoryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			out.Values[i] = ec._Repository_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dateCreated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_dateCreated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateUpdated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_dateUpdated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "labels":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_labels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "collaborators":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_collaborators(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allowedActions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_allowedActions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "tags":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "branches":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_branches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "commit":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_commit(ctx, field, obj)
				return res
			})
		case "tag":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_tag(ctx, field, obj)
				return res
			})
		case "branch":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_branch(ctx, field, obj)
				return res
			})
		case "commitByReference":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_commitByReference(ctx, field, obj)
				return res
			})
		case "diff":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_diff(ctx, field, obj)
				return res
			})
		case "log":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_log(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "network":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_network(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "delete":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_delete(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "addLabels":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_addLabels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "deleteLabels":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_deleteLabels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "merge":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_merge(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryBranchImplementors = []string{"RepositoryBranch"}

func (ec *executionContext) _RepositoryBranch(ctx context.Context, sel ast.SelectionSet, obj *models.RepositoryBranch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, repositoryBranchImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryBranch")
		case "name":
			out.Values[i] = ec._RepositoryBranch_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "commit":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepositoryBranch_commit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryTagImplementors = []string{"RepositoryTag"}

func (ec *executionContext) _RepositoryTag(ctx context.Context, sel ast.SelectionSet, obj *models.RepositoryTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, repositoryTagImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepositoryTag")
		case "name":
			out.Values[i] = ec._RepositoryTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "commit":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepositoryTag_commit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stringKeyValueImplementors = []string{"StringKeyValue", "KeyValue"}

func (ec *executionContext) _StringKeyValue(ctx context.Context, sel ast.SelectionSet, obj *StringKeyValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, stringKeyValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StringKeyValue")
		case "key":
			out.Values[i] = ec._StringKeyValue_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._StringKeyValue_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamImplementors = []string{"Team"}

func (ec *executionContext) _Team(ctx context.Context, sel ast.SelectionSet, obj *uac.Team) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Team")
		case "id":
			out.Values[i] = ec._Team_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "organizationId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_organizationId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "organization":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_organization(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			out.Values[i] = ec._Team_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "shortName":
			out.Values[i] = ec._Team_shortName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Team_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "owner":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_owner(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateCreated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_dateCreated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "dateUpdated":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_dateUpdated(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamCollaboratorImplementors = []string{"TeamCollaborator", "Collaborator"}

func (ec *executionContext) _TeamCollaborator(ctx context.Context, sel ast.SelectionSet, obj *models.TeamCollaborator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamCollaboratorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamCollaborator")
		case "team":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamCollaborator_team(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "type":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamCollaborator_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "canDeploy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TeamCollaborator_canDeploy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *uac.UserInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_name(ctx, field, obj)
				return res
			})
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "picture":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_picture(ctx, field, obj)
				return res
			})
		case "roles":
			out.Values[i] = ec._User_roles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "username":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_username(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userCollaboratorImplementors = []string{"UserCollaborator", "Collaborator"}

func (ec *executionContext) _UserCollaborator(ctx context.Context, sel ast.SelectionSet, obj *models.UserCollaborator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userCollaboratorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserCollaborator")
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserCollaborator_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "type":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserCollaborator_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "canDeploy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserCollaborator_canDeploy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workspaceImplementors = []string{"Workspace"}

func (ec *executionContext) _Workspace(ctx context.Context, sel ast.SelectionSet, obj *models.Workspace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, workspaceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Workspace")
		case "name":
			out.Values[i] = ec._Workspace_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "projects":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Workspace_projects(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "datasets":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Workspace_datasets(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "datasetVersions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Workspace_datasetVersions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "createDataset":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Workspace_createDataset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "repositories":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Workspace_repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "repository":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Workspace_repository(ctx, field, obj)
				return res
			})
		case "createRepository":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Workspace_createRepository(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAccessType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAccessType(ctx context.Context, v interface{}) (AccessType, error) {
	var res AccessType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAccessType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAccessType(ctx context.Context, sel ast.SelectionSet, v AccessType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAllowedActions2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAllowedActions(ctx context.Context, sel ast.SelectionSet, v AllowedActions) graphql.Marshaler {
	return ec._AllowedActions(ctx, sel, &v)
}

func (ec *executionContext) marshalNAllowedActions2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐAllowedActions(ctx context.Context, sel ast.SelectionSet, v *AllowedActions) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AllowedActions(ctx, sel, v)
}

func (ec *executionContext) marshalNArtifact2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx context.Context, sel ast.SelectionSet, v common.Artifact) graphql.Marshaler {
	return ec._Artifact(ctx, sel, &v)
}

func (ec *executionContext) marshalNArtifact2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx context.Context, sel ast.SelectionSet, v []*common.Artifact) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNArtifact2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNArtifact2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx context.Context, sel ast.SelectionSet, v *common.Artifact) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Artifact(ctx, sel, v)
}

func (ec *executionContext) unmarshalNArtifactType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐArtifactType(ctx context.Context, v interface{}) (ArtifactType, error) {
	var res ArtifactType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNArtifactType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐArtifactType(ctx context.Context, sel ast.SelectionSet, v ArtifactType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNBranchesNetwork2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐBranchesNetwork(ctx context.Context, sel ast.SelectionSet, v BranchesNetwork) graphql.Marshaler {
	return ec._BranchesNetwork(ctx, sel, &v)
}

func (ec *executionContext) marshalNBranchesNetwork2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐBranchesNetwork(ctx context.Context, sel ast.SelectionSet, v *BranchesNetwork) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._BranchesNetwork(ctx, sel, v)
}

func (ec *executionContext) marshalNCollaborator2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCollaborator(ctx context.Context, sel ast.SelectionSet, v Collaborator) graphql.Marshaler {
	return ec._Collaborator(ctx, sel, &v)
}

func (ec *executionContext) marshalNCollaborator2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCollaborator(ctx context.Context, sel ast.SelectionSet, v []Collaborator) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCollaborator2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCollaborator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCommit2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v models.Commit) graphql.Marshaler {
	return ec._Commit(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommit2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v []*models.Commit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v *models.Commit) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Commit(ctx, sel, v)
}

func (ec *executionContext) marshalNCommitBlob2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommitBlob(ctx context.Context, sel ast.SelectionSet, v models.CommitBlob) graphql.Marshaler {
	return ec._CommitBlob(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommitBlob2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommitBlob(ctx context.Context, sel ast.SelectionSet, v *models.CommitBlob) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._CommitBlob(ctx, sel, v)
}

func (ec *executionContext) marshalNCommitFolder2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitFolder(ctx context.Context, sel ast.SelectionSet, v CommitFolder) graphql.Marshaler {
	return ec._CommitFolder(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommitFolder2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitFolder(ctx context.Context, sel ast.SelectionSet, v *CommitFolder) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._CommitFolder(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCommitReference2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitReference(ctx context.Context, v interface{}) (CommitReference, error) {
	return ec.unmarshalInputCommitReference(ctx, v)
}

func (ec *executionContext) marshalNCommits2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommits(ctx context.Context, sel ast.SelectionSet, v Commits) graphql.Marshaler {
	return ec._Commits(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommits2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommits(ctx context.Context, sel ast.SelectionSet, v *Commits) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Commits(ctx, sel, v)
}

func (ec *executionContext) marshalNDataset2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx context.Context, sel ast.SelectionSet, v modeldb.Dataset) graphql.Marshaler {
	return ec._Dataset(ctx, sel, &v)
}

func (ec *executionContext) marshalNDataset2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx context.Context, sel ast.SelectionSet, v []*modeldb.Dataset) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNDataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx context.Context, sel ast.SelectionSet, v *modeldb.Dataset) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Dataset(ctx, sel, v)
}

func (ec *executionContext) marshalNDatasetVersion2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDatasetVersion(ctx context.Context, sel ast.SelectionSet, v modeldb.DatasetVersion) graphql.Marshaler {
	return ec._DatasetVersion(ctx, sel, &v)
}

func (ec *executionContext) marshalNDatasetVersion2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDatasetVersion(ctx context.Context, sel ast.SelectionSet, v []*modeldb.DatasetVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDatasetVersion2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDatasetVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNDatasetVersion2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDatasetVersion(ctx context.Context, sel ast.SelectionSet, v *modeldb.DatasetVersion) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._DatasetVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNDatasetVersions2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersions(ctx context.Context, sel ast.SelectionSet, v DatasetVersions) graphql.Marshaler {
	return ec._DatasetVersions(ctx, sel, &v)
}

func (ec *executionContext) marshalNDatasetVersions2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersions(ctx context.Context, sel ast.SelectionSet, v *DatasetVersions) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._DatasetVersions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDatasetVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVisibility(ctx context.Context, v interface{}) (DatasetVisibility, error) {
	var res DatasetVisibility
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNDatasetVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVisibility(ctx context.Context, sel ast.SelectionSet, v DatasetVisibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDatasets2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasets(ctx context.Context, sel ast.SelectionSet, v Datasets) graphql.Marshaler {
	return ec._Datasets(ctx, sel, &v)
}

func (ec *executionContext) marshalNDatasets2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasets(ctx context.Context, sel ast.SelectionSet, v *Datasets) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Datasets(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDate2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNExperiment2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx context.Context, sel ast.SelectionSet, v modeldb.Experiment) graphql.Marshaler {
	return ec._Experiment(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperiment2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx context.Context, sel ast.SelectionSet, v []*modeldb.Experiment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExperiment2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperiment2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx context.Context, sel ast.SelectionSet, v *modeldb.Experiment) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Experiment(ctx, sel, v)
}

func (ec *executionContext) marshalNExperimentRun2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v modeldb.ExperimentRun) graphql.Marshaler {
	return ec._ExperimentRun(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperimentRun2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v []*modeldb.ExperimentRun) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExperimentRun2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNExperimentRun2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v *modeldb.ExperimentRun) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ExperimentRun(ctx, sel, v)
}

func (ec *executionContext) marshalNExperimentRuns2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRuns(ctx context.Context, sel ast.SelectionSet, v ExperimentRuns) graphql.Marshaler {
	return ec._ExperimentRuns(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperimentRuns2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRuns(ctx context.Context, sel ast.SelectionSet, v *ExperimentRuns) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ExperimentRuns(ctx, sel, v)
}

func (ec *executionContext) marshalNExperiments2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperiments(ctx context.Context, sel ast.SelectionSet, v Experiments) graphql.Marshaler {
	return ec._Experiments(ctx, sel, &v)
}

func (ec *executionContext) marshalNExperiments2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperiments(ctx context.Context, sel ast.SelectionSet, v *Experiments) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Experiments(ctx, sel, v)
}

func (ec *executionContext) marshalNFeature2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐFeature(ctx context.Context, sel ast.SelectionSet, v modeldb.Feature) graphql.Marshaler {
	return ec._Feature(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeature2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐFeature(ctx context.Context, sel ast.SelectionSet, v []*modeldb.Feature) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeature2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐFeature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNFeature2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐFeature(ctx context.Context, sel ast.SelectionSet, v *modeldb.Feature) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Feature(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNFloatPredicate2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐFloatPredicate(ctx context.Context, v interface{}) (FloatPredicate, error) {
	return ec.unmarshalInputFloatPredicate(ctx, v)
}

func (ec *executionContext) unmarshalNFloatPredicate2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐFloatPredicate(ctx context.Context, v interface{}) (*FloatPredicate, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNFloatPredicate2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐFloatPredicate(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNKeyValue2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx context.Context, sel ast.SelectionSet, v KeyValue) graphql.Marshaler {
	return ec._KeyValue(ctx, sel, &v)
}

func (ec *executionContext) marshalNKeyValue2ᚕgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx context.Context, sel ast.SelectionSet, v []KeyValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNKeyValue2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMergeResult2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐMergeResult(ctx context.Context, sel ast.SelectionSet, v MergeResult) graphql.Marshaler {
	return ec._MergeResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNMergeResult2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐMergeResult(ctx context.Context, sel ast.SelectionSet, v *MergeResult) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._MergeResult(ctx, sel, v)
}

func (ec *executionContext) marshalNNamedCommitBlob2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitBlob(ctx context.Context, sel ast.SelectionSet, v models.NamedCommitBlob) graphql.Marshaler {
	return ec._NamedCommitBlob(ctx, sel, &v)
}

func (ec *executionContext) marshalNNamedCommitBlob2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitBlob(ctx context.Context, sel ast.SelectionSet, v []*models.NamedCommitBlob) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNamedCommitBlob2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitBlob(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNNamedCommitBlob2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitBlob(ctx context.Context, sel ast.SelectionSet, v *models.NamedCommitBlob) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._NamedCommitBlob(ctx, sel, v)
}

func (ec *executionContext) marshalNNamedCommitFolder2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitFolder(ctx context.Context, sel ast.SelectionSet, v models.NamedCommitFolder) graphql.Marshaler {
	return ec._NamedCommitFolder(ctx, sel, &v)
}

func (ec *executionContext) marshalNNamedCommitFolder2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitFolder(ctx context.Context, sel ast.SelectionSet, v []*models.NamedCommitFolder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNamedCommitFolder2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitFolder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNNamedCommitFolder2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNamedCommitFolder(ctx context.Context, sel ast.SelectionSet, v *models.NamedCommitFolder) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._NamedCommitFolder(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkBranchColor2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkBranchColor(ctx context.Context, sel ast.SelectionSet, v NetworkBranchColor) graphql.Marshaler {
	return ec._NetworkBranchColor(ctx, sel, &v)
}

func (ec *executionContext) marshalNNetworkBranchColor2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkBranchColor(ctx context.Context, sel ast.SelectionSet, v []*NetworkBranchColor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkBranchColor2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkBranchColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNNetworkBranchColor2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkBranchColor(ctx context.Context, sel ast.SelectionSet, v *NetworkBranchColor) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._NetworkBranchColor(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkCommitColor2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNetworkCommitColor(ctx context.Context, sel ast.SelectionSet, v models.NetworkCommitColor) graphql.Marshaler {
	return ec._NetworkCommitColor(ctx, sel, &v)
}

func (ec *executionContext) marshalNNetworkCommitColor2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNetworkCommitColor(ctx context.Context, sel ast.SelectionSet, v []*models.NetworkCommitColor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkCommitColor2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNetworkCommitColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNNetworkCommitColor2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐNetworkCommitColor(ctx context.Context, sel ast.SelectionSet, v *models.NetworkCommitColor) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._NetworkCommitColor(ctx, sel, v)
}

func (ec *executionContext) marshalNNetworkEdgeColor2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkEdgeColor(ctx context.Context, sel ast.SelectionSet, v NetworkEdgeColor) graphql.Marshaler {
	return ec._NetworkEdgeColor(ctx, sel, &v)
}

func (ec *executionContext) marshalNNetworkEdgeColor2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkEdgeColor(ctx context.Context, sel ast.SelectionSet, v []*NetworkEdgeColor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNetworkEdgeColor2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkEdgeColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNNetworkEdgeColor2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkEdgeColor(ctx context.Context, sel ast.SelectionSet, v *NetworkEdgeColor) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._NetworkEdgeColor(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNetworkEdgeType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkEdgeType(ctx context.Context, v interface{}) (NetworkEdgeType, error) {
	var res NetworkEdgeType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNNetworkEdgeType2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐNetworkEdgeType(ctx context.Context, sel ast.SelectionSet, v NetworkEdgeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNObservation2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐObservation(ctx context.Context, sel ast.SelectionSet, v modeldb.Observation) graphql.Marshaler {
	return ec._Observation(ctx, sel, &v)
}

func (ec *executionContext) marshalNObservation2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐObservation(ctx context.Context, sel ast.SelectionSet, v []*modeldb.Observation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNObservation2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐObservation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNObservation2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐObservation(ctx context.Context, sel ast.SelectionSet, v *modeldb.Observation) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Observation(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganization2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx context.Context, sel ast.SelectionSet, v uac.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganization2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx context.Context, sel ast.SelectionSet, v []*uac.Organization) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrganization2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOrganization2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx context.Context, sel ast.SelectionSet, v *uac.Organization) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) marshalNPaginationResponse2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationResponse(ctx context.Context, sel ast.SelectionSet, v PaginationResponse) graphql.Marshaler {
	return ec._PaginationResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPaginationResponse2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationResponse(ctx context.Context, sel ast.SelectionSet, v *PaginationResponse) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PaginationResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPredicateOperator2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPredicateOperator(ctx context.Context, v interface{}) (PredicateOperator, error) {
	var res PredicateOperator
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPredicateOperator2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPredicateOperator(ctx context.Context, sel ast.SelectionSet, v PredicateOperator) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProject2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx context.Context, sel ast.SelectionSet, v modeldb.Project) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalNProject2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx context.Context, sel ast.SelectionSet, v []*modeldb.Project) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx context.Context, sel ast.SelectionSet, v *modeldb.Project) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjectVisibility(ctx context.Context, v interface{}) (ProjectVisibility, error) {
	var res ProjectVisibility
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNProjectVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjectVisibility(ctx context.Context, sel ast.SelectionSet, v ProjectVisibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProjects2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjects(ctx context.Context, sel ast.SelectionSet, v Projects) graphql.Marshaler {
	return ec._Projects(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjects2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjects(ctx context.Context, sel ast.SelectionSet, v *Projects) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Projects(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositories2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐRepositories(ctx context.Context, sel ast.SelectionSet, v Repositories) graphql.Marshaler {
	return ec._Repositories(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositories2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐRepositories(ctx context.Context, sel ast.SelectionSet, v *Repositories) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Repositories(ctx, sel, v)
}

func (ec *executionContext) marshalNRepository2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx context.Context, sel ast.SelectionSet, v versioning.Repository) graphql.Marshaler {
	return ec._Repository(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepository2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx context.Context, sel ast.SelectionSet, v []*versioning.Repository) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx context.Context, sel ast.SelectionSet, v *versioning.Repository) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryBranch2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryBranch(ctx context.Context, sel ast.SelectionSet, v models.RepositoryBranch) graphql.Marshaler {
	return ec._RepositoryBranch(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryBranch2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryBranch(ctx context.Context, sel ast.SelectionSet, v []*models.RepositoryBranch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryBranch2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryBranch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRepositoryBranch2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryBranch(ctx context.Context, sel ast.SelectionSet, v *models.RepositoryBranch) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepositoryBranch(ctx, sel, v)
}

func (ec *executionContext) marshalNRepositoryTag2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryTag(ctx context.Context, sel ast.SelectionSet, v models.RepositoryTag) graphql.Marshaler {
	return ec._RepositoryTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepositoryTag2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryTag(ctx context.Context, sel ast.SelectionSet, v []*models.RepositoryTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRepositoryTag2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRepositoryTag2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐRepositoryTag(ctx context.Context, sel ast.SelectionSet, v *models.RepositoryTag) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._RepositoryTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNStringPredicate2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐStringPredicate(ctx context.Context, v interface{}) (StringPredicate, error) {
	return ec.unmarshalInputStringPredicate(ctx, v)
}

func (ec *executionContext) unmarshalNStringPredicate2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐStringPredicate(ctx context.Context, v interface{}) (*StringPredicate, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNStringPredicate2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐStringPredicate(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNTeam2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐTeam(ctx context.Context, sel ast.SelectionSet, v uac.Team) graphql.Marshaler {
	return ec._Team(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeam2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐTeam(ctx context.Context, sel ast.SelectionSet, v []*uac.Team) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeam2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTeam2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐTeam(ctx context.Context, sel ast.SelectionSet, v *uac.Team) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx context.Context, sel ast.SelectionSet, v uac.UserInfo) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx context.Context, sel ast.SelectionSet, v *uac.UserInfo) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐVisibility(ctx context.Context, v interface{}) (Visibility, error) {
	var res Visibility
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNVisibility2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐVisibility(ctx context.Context, sel ast.SelectionSet, v Visibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOArtifact2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx context.Context, sel ast.SelectionSet, v common.Artifact) graphql.Marshaler {
	return ec._Artifact(ctx, sel, &v)
}

func (ec *executionContext) marshalOArtifact2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋcommonᚐArtifact(ctx context.Context, sel ast.SelectionSet, v *common.Artifact) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Artifact(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalOCommit2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v models.Commit) graphql.Marshaler {
	return ec._Commit(ctx, sel, &v)
}

func (ec *executionContext) marshalOCommit2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐCommit(ctx context.Context, sel ast.SelectionSet, v *models.Commit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Commit(ctx, sel, v)
}

func (ec *executionContext) marshalOCommitAsDiff2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitAsDiff(ctx context.Context, sel ast.SelectionSet, v CommitAsDiff) graphql.Marshaler {
	return ec._CommitAsDiff(ctx, sel, &v)
}

func (ec *executionContext) marshalOCommitAsDiff2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitAsDiff(ctx context.Context, sel ast.SelectionSet, v *CommitAsDiff) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CommitAsDiff(ctx, sel, v)
}

func (ec *executionContext) marshalOCommitElement2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐCommitElement(ctx context.Context, sel ast.SelectionSet, v CommitElement) graphql.Marshaler {
	return ec._CommitElement(ctx, sel, &v)
}

func (ec *executionContext) marshalODataset2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx context.Context, sel ast.SelectionSet, v modeldb.Dataset) graphql.Marshaler {
	return ec._Dataset(ctx, sel, &v)
}

func (ec *executionContext) marshalODataset2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐDataset(ctx context.Context, sel ast.SelectionSet, v *modeldb.Dataset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Dataset(ctx, sel, v)
}

func (ec *executionContext) unmarshalODatasetVersionsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersionsQuery(ctx context.Context, v interface{}) (DatasetVersionsQuery, error) {
	return ec.unmarshalInputDatasetVersionsQuery(ctx, v)
}

func (ec *executionContext) unmarshalODatasetVersionsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersionsQuery(ctx context.Context, v interface{}) (*DatasetVersionsQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODatasetVersionsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetVersionsQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODatasetsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetsQuery(ctx context.Context, v interface{}) (DatasetsQuery, error) {
	return ec.unmarshalInputDatasetsQuery(ctx, v)
}

func (ec *executionContext) unmarshalODatasetsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetsQuery(ctx context.Context, v interface{}) (*DatasetsQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODatasetsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐDatasetsQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalODate2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalODate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalODate2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODate2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODate2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalODate2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOExperiment2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx context.Context, sel ast.SelectionSet, v modeldb.Experiment) graphql.Marshaler {
	return ec._Experiment(ctx, sel, &v)
}

func (ec *executionContext) marshalOExperiment2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperiment(ctx context.Context, sel ast.SelectionSet, v *modeldb.Experiment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Experiment(ctx, sel, v)
}

func (ec *executionContext) marshalOExperimentRun2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v modeldb.ExperimentRun) graphql.Marshaler {
	return ec._ExperimentRun(ctx, sel, &v)
}

func (ec *executionContext) marshalOExperimentRun2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐExperimentRun(ctx context.Context, sel ast.SelectionSet, v *modeldb.ExperimentRun) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ExperimentRun(ctx, sel, v)
}

func (ec *executionContext) unmarshalOExperimentRunsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRunsQuery(ctx context.Context, v interface{}) (ExperimentRunsQuery, error) {
	return ec.unmarshalInputExperimentRunsQuery(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentRunsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRunsQuery(ctx context.Context, v interface{}) (*ExperimentRunsQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentRunsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentRunsQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOExperimentsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentsQuery(ctx context.Context, v interface{}) (ExperimentsQuery, error) {
	return ec.unmarshalInputExperimentsQuery(ctx, v)
}

func (ec *executionContext) unmarshalOExperimentsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentsQuery(ctx context.Context, v interface{}) (*ExperimentsQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOExperimentsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐExperimentsQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOFloatPredicate2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐFloatPredicate(ctx context.Context, v interface{}) ([]*FloatPredicate, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*FloatPredicate, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNFloatPredicate2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐFloatPredicate(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚕint(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕint(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) marshalOKeyValue2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐKeyValue(ctx context.Context, sel ast.SelectionSet, v KeyValue) graphql.Marshaler {
	return ec._KeyValue(ctx, sel, &v)
}

func (ec *executionContext) marshalOOrganization2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx context.Context, sel ast.SelectionSet, v uac.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalOOrganization2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐOrganization(ctx context.Context, sel ast.SelectionSet, v *uac.Organization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPaginationQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx context.Context, v interface{}) (PaginationQuery, error) {
	return ec.unmarshalInputPaginationQuery(ctx, v)
}

func (ec *executionContext) unmarshalOPaginationQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx context.Context, v interface{}) (*PaginationQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPaginationQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐPaginationQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOProject2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx context.Context, sel ast.SelectionSet, v modeldb.Project) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalOProject2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚐProject(ctx context.Context, sel ast.SelectionSet, v *modeldb.Project) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjectsQuery(ctx context.Context, v interface{}) (ProjectsQuery, error) {
	return ec.unmarshalInputProjectsQuery(ctx, v)
}

func (ec *executionContext) unmarshalOProjectsQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjectsQuery(ctx context.Context, v interface{}) (*ProjectsQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOProjectsQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐProjectsQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalORepositoriesQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐRepositoriesQuery(ctx context.Context, v interface{}) (RepositoriesQuery, error) {
	return ec.unmarshalInputRepositoriesQuery(ctx, v)
}

func (ec *executionContext) unmarshalORepositoriesQuery2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐRepositoriesQuery(ctx context.Context, v interface{}) (*RepositoriesQuery, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalORepositoriesQuery2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐRepositoriesQuery(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalORepository2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx context.Context, sel ast.SelectionSet, v versioning.Repository) graphql.Marshaler {
	return ec._Repository(ctx, sel, &v)
}

func (ec *executionContext) marshalORepository2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋmodeldbᚋversioningᚐRepository(ctx context.Context, sel ast.SelectionSet, v *versioning.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOStringPredicate2ᚕᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐStringPredicate(ctx context.Context, v interface{}) ([]*StringPredicate, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*StringPredicate, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNStringPredicate2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚐStringPredicate(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUser2githubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx context.Context, sel ast.SelectionSet, v uac.UserInfo) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋprotosᚋgenᚋgoᚋprotosᚋpublicᚋuacᚐUserInfo(ctx context.Context, sel ast.SelectionSet, v *uac.UserInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalOWorkspace2githubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐWorkspace(ctx context.Context, sel ast.SelectionSet, v models.Workspace) graphql.Marshaler {
	return ec._Workspace(ctx, sel, &v)
}

func (ec *executionContext) marshalOWorkspace2ᚖgithubᚗcomᚋVertaAIᚋmodeldbᚋbackendᚋgraphqlᚋinternalᚋschemaᚋmodelsᚐWorkspace(ctx context.Context, sel ast.SelectionSet, v *models.Workspace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Workspace(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
