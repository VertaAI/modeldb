// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package schema

import (
	"fmt"
	"io"
	"strconv"

	"github.com/VertaAI/modeldb/backend/graphql/internal/schema/models"
	"github.com/VertaAI/modeldb/protos/gen/go/protos/public/modeldb"
	"github.com/VertaAI/modeldb/protos/gen/go/protos/public/modeldb/versioning"
)

type Collaborator interface {
	IsCollaborator()
}

type CommitElement interface {
	IsCommitElement()
}

type KeyValue interface {
	IsKeyValue()
}

type AllowedActions struct {
	Create bool `json:"create"`
	Update bool `json:"update"`
	Delete bool `json:"delete"`
	Deploy bool `json:"deploy"`
}

type BranchesNetwork struct {
	Branches []*NetworkBranchColor        `json:"branches"`
	Commits  []*models.NetworkCommitColor `json:"commits"`
	Edges    []*NetworkEdgeColor          `json:"edges"`
}

type CollaboratorReference struct {
	UsernameOrEmail *string `json:"usernameOrEmail"`
	TeamID          *string `json:"teamID"`
}

type CommitAsDiff struct {
	Parent string   `json:"parent"`
	Diff   []string `json:"diff"`
}

type CommitFolder struct {
	Subfolders []*models.NamedCommitFolder `json:"subfolders"`
	Blobs      []*models.NamedCommitBlob   `json:"blobs"`
}

func (CommitFolder) IsCommitElement() {}

type CommitReference struct {
	Commit *string `json:"commit"`
	Tag    *string `json:"tag"`
	Branch *string `json:"branch"`
}

type Commits struct {
	Commits []*models.Commit `json:"commits"`
}

type DatasetVersions struct {
	DatasetVersions []*modeldb.DatasetVersion `json:"datasetVersions"`
	Total           int                       `json:"total"`
}

type DatasetVersionsQuery struct {
	Pagination       *PaginationQuery   `json:"pagination"`
	StringPredicates []*StringPredicate `json:"stringPredicates"`
	FloatPredicates  []*FloatPredicate  `json:"floatPredicates"`
	Ids              []string           `json:"ids"`
}

type Datasets struct {
	Datasets []*modeldb.Dataset `json:"datasets"`
	Total    int                `json:"total"`
}

type DatasetsQuery struct {
	Pagination       *PaginationQuery   `json:"pagination"`
	StringPredicates []*StringPredicate `json:"stringPredicates"`
	FloatPredicates  []*FloatPredicate  `json:"floatPredicates"`
	Ids              []string           `json:"ids"`
}

type ExperimentRuns struct {
	Runs       []*modeldb.ExperimentRun `json:"runs"`
	Next       *string                  `json:"next"`
	Pagination *PaginationResponse      `json:"pagination"`
}

type ExperimentRunsQuery struct {
	Pagination *PaginationQuery `json:"pagination"`
}

type Experiments struct {
	Experiments []*modeldb.Experiment `json:"experiments"`
	Next        *string               `json:"next"`
}

type ExperimentsQuery struct {
	Pagination *PaginationQuery `json:"pagination"`
}

type FloatKeyValue struct {
	Key   string  `json:"key"`
	Value float64 `json:"value"`
}

func (FloatKeyValue) IsKeyValue() {}

type FloatPredicate struct {
	Key      string            `json:"key"`
	Value    float64           `json:"value"`
	Operator PredicateOperator `json:"operator"`
}

type MergeResult struct {
	Commit     *models.Commit `json:"commit"`
	CommonBase *models.Commit `json:"commonBase"`
	Conflicts  []string       `json:"conflicts"`
}

type NetworkBranchColor struct {
	Branch      string `json:"branch"`
	Color       int    `json:"color"`
	CommitIndex int    `json:"commitIndex"`
}

type NetworkEdgeColor struct {
	FromCommitIndex int             `json:"fromCommitIndex"`
	ToCommitIndex   int             `json:"toCommitIndex"`
	Color           int             `json:"color"`
	EdgeType        NetworkEdgeType `json:"edgeType"`
}

type PaginationQuery struct {
	Page  *int `json:"page"`
	Limit *int `json:"limit"`
}

type PaginationResponse struct {
	Page         int `json:"page"`
	Limit        int `json:"limit"`
	TotalRecords int `json:"totalRecords"`
}

type Projects struct {
	Projects []*modeldb.Project `json:"projects"`
	Next     *string            `json:"next"`
}

type ProjectsQuery struct {
	Pagination *PaginationQuery `json:"pagination"`
}

type Repositories struct {
	Repositories []*versioning.Repository `json:"repositories"`
	Next         *string                  `json:"next"`
	Pagination   *PaginationResponse      `json:"pagination"`
}

type RepositoriesQuery struct {
	Pagination       *PaginationQuery   `json:"pagination"`
	StringPredicates []*StringPredicate `json:"stringPredicates"`
	FloatPredicates  []*FloatPredicate  `json:"floatPredicates"`
	Ids              []int              `json:"ids"`
}

type StringKeyValue struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (StringKeyValue) IsKeyValue() {}

type StringPredicate struct {
	Key      string            `json:"key"`
	Value    string            `json:"value"`
	Operator PredicateOperator `json:"operator"`
}

type AccessType string

const (
	AccessTypeOwner     AccessType = "OWNER"
	AccessTypeReadOnly  AccessType = "READ_ONLY"
	AccessTypeReadWrite AccessType = "READ_WRITE"
)

var AllAccessType = []AccessType{
	AccessTypeOwner,
	AccessTypeReadOnly,
	AccessTypeReadWrite,
}

func (e AccessType) IsValid() bool {
	switch e {
	case AccessTypeOwner, AccessTypeReadOnly, AccessTypeReadWrite:
		return true
	}
	return false
}

func (e AccessType) String() string {
	return string(e)
}

func (e *AccessType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessType", str)
	}
	return nil
}

func (e AccessType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ArtifactType string

const (
	ArtifactTypeImage       ArtifactType = "IMAGE"
	ArtifactTypeModel       ArtifactType = "MODEL"
	ArtifactTypeTensorboard ArtifactType = "TENSORBOARD"
	ArtifactTypeData        ArtifactType = "DATA"
	ArtifactTypeBlob        ArtifactType = "BLOB"
	ArtifactTypeString      ArtifactType = "STRING"
)

var AllArtifactType = []ArtifactType{
	ArtifactTypeImage,
	ArtifactTypeModel,
	ArtifactTypeTensorboard,
	ArtifactTypeData,
	ArtifactTypeBlob,
	ArtifactTypeString,
}

func (e ArtifactType) IsValid() bool {
	switch e {
	case ArtifactTypeImage, ArtifactTypeModel, ArtifactTypeTensorboard, ArtifactTypeData, ArtifactTypeBlob, ArtifactTypeString:
		return true
	}
	return false
}

func (e ArtifactType) String() string {
	return string(e)
}

func (e *ArtifactType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ArtifactType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ArtifactType", str)
	}
	return nil
}

func (e ArtifactType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DatasetVisibility string

const (
	DatasetVisibilityPrivate DatasetVisibility = "PRIVATE"
	DatasetVisibilityPublic  DatasetVisibility = "PUBLIC"
)

var AllDatasetVisibility = []DatasetVisibility{
	DatasetVisibilityPrivate,
	DatasetVisibilityPublic,
}

func (e DatasetVisibility) IsValid() bool {
	switch e {
	case DatasetVisibilityPrivate, DatasetVisibilityPublic:
		return true
	}
	return false
}

func (e DatasetVisibility) String() string {
	return string(e)
}

func (e *DatasetVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DatasetVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DatasetVisibility", str)
	}
	return nil
}

func (e DatasetVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkEdgeType string

const (
	NetworkEdgeTypeDefault NetworkEdgeType = "DEFAULT"
	NetworkEdgeTypeBranch  NetworkEdgeType = "BRANCH"
	NetworkEdgeTypeMerge   NetworkEdgeType = "MERGE"
)

var AllNetworkEdgeType = []NetworkEdgeType{
	NetworkEdgeTypeDefault,
	NetworkEdgeTypeBranch,
	NetworkEdgeTypeMerge,
}

func (e NetworkEdgeType) IsValid() bool {
	switch e {
	case NetworkEdgeTypeDefault, NetworkEdgeTypeBranch, NetworkEdgeTypeMerge:
		return true
	}
	return false
}

func (e NetworkEdgeType) String() string {
	return string(e)
}

func (e *NetworkEdgeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkEdgeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkEdgeType", str)
	}
	return nil
}

func (e NetworkEdgeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PredicateOperator string

const (
	PredicateOperatorEq         PredicateOperator = "EQ"
	PredicateOperatorNe         PredicateOperator = "NE"
	PredicateOperatorGt         PredicateOperator = "GT"
	PredicateOperatorGte        PredicateOperator = "GTE"
	PredicateOperatorLt         PredicateOperator = "LT"
	PredicateOperatorLte        PredicateOperator = "LTE"
	PredicateOperatorContain    PredicateOperator = "CONTAIN"
	PredicateOperatorNotContain PredicateOperator = "NOT_CONTAIN"
	PredicateOperatorIn         PredicateOperator = "IN"
)

var AllPredicateOperator = []PredicateOperator{
	PredicateOperatorEq,
	PredicateOperatorNe,
	PredicateOperatorGt,
	PredicateOperatorGte,
	PredicateOperatorLt,
	PredicateOperatorLte,
	PredicateOperatorContain,
	PredicateOperatorNotContain,
	PredicateOperatorIn,
}

func (e PredicateOperator) IsValid() bool {
	switch e {
	case PredicateOperatorEq, PredicateOperatorNe, PredicateOperatorGt, PredicateOperatorGte, PredicateOperatorLt, PredicateOperatorLte, PredicateOperatorContain, PredicateOperatorNotContain, PredicateOperatorIn:
		return true
	}
	return false
}

func (e PredicateOperator) String() string {
	return string(e)
}

func (e *PredicateOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PredicateOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PredicateOperator", str)
	}
	return nil
}

func (e PredicateOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProjectVisibility string

const (
	ProjectVisibilityPrivate ProjectVisibility = "PRIVATE"
	ProjectVisibilityPublic  ProjectVisibility = "PUBLIC"
)

var AllProjectVisibility = []ProjectVisibility{
	ProjectVisibilityPrivate,
	ProjectVisibilityPublic,
}

func (e ProjectVisibility) IsValid() bool {
	switch e {
	case ProjectVisibilityPrivate, ProjectVisibilityPublic:
		return true
	}
	return false
}

func (e ProjectVisibility) String() string {
	return string(e)
}

func (e *ProjectVisibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectVisibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectVisibility", str)
	}
	return nil
}

func (e ProjectVisibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visibility string

const (
	VisibilityPrivate         Visibility = "PRIVATE"
	VisibilityPublic          Visibility = "PUBLIC"
	VisibilityOrgScopedPublic Visibility = "ORG_SCOPED_PUBLIC"
)

var AllVisibility = []Visibility{
	VisibilityPrivate,
	VisibilityPublic,
	VisibilityOrgScopedPublic,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityPrivate, VisibilityPublic, VisibilityOrgScopedPublic:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
