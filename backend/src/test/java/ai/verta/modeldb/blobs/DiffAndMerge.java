package ai.verta.modeldb.blobs;

import static ai.verta.modeldb.blobs.Utils.enforceOneof;
import static org.junit.Assert.*;
import static org.junit.Assume.*;

import ai.verta.modeldb.ModelDBException;
import ai.verta.modeldb.versioning.autogenerated._public.modeldb.versioning.model.*;
import ai.verta.modeldb.versioning.blob.diff.*;
import com.pholser.junit.quickcheck.Property;
import com.pholser.junit.quickcheck.runner.JUnitQuickcheck;
import org.junit.runner.RunWith;

@RunWith(JUnitQuickcheck.class)
public class DiffAndMerge {
  @Property
  public void diffAndMerge(Blob a, Blob b) throws ModelDBException {
    Blob newA = enforceOneof(a);
    Blob newB = enforceOneof(b);
    BlobDiff d = DiffComputer.computeBlobDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    Blob diffedB = DiffMerger.mergeBlob(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeBlob(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeCode(CodeBlob a, CodeBlob b) throws ModelDBException {
    CodeBlob newA = enforceOneof(a);
    CodeBlob newB = enforceOneof(b);
    CodeDiff d = DiffComputer.computeCodeDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    CodeBlob diffedB = DiffMerger.mergeCode(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeCode(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeConfig(ConfigBlob a, ConfigBlob b) throws ModelDBException {
    ConfigBlob newA = enforceOneof(a);
    ConfigBlob newB = enforceOneof(b);
    ConfigDiff d = DiffComputer.computeConfigDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    ConfigBlob diffedB = DiffMerger.mergeConfig(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeConfig(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeDataset(DatasetBlob a, DatasetBlob b) throws ModelDBException {
    DatasetBlob newA = enforceOneof(a);
    DatasetBlob newB = enforceOneof(b);
    DatasetDiff d = DiffComputer.computeDatasetDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    DatasetBlob diffedB = DiffMerger.mergeDataset(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeDataset(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeDockerEnvironment(DockerEnvironmentBlob a, DockerEnvironmentBlob b)
      throws ModelDBException {
    DockerEnvironmentBlob newA = enforceOneof(a);
    DockerEnvironmentBlob newB = enforceOneof(b);
    DockerEnvironmentDiff d = DiffComputer.computeDockerEnvironmentDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    DockerEnvironmentBlob diffedB = DiffMerger.mergeDockerEnvironment(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeDockerEnvironment(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeEnvironment(EnvironmentBlob a, EnvironmentBlob b)
      throws ModelDBException {
    EnvironmentBlob newA = enforceOneof(a);
    EnvironmentBlob newB = enforceOneof(b);
    EnvironmentDiff d = DiffComputer.computeEnvironmentDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    EnvironmentBlob diffedB = DiffMerger.mergeEnvironment(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeEnvironment(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeGitCode(GitCodeBlob a, GitCodeBlob b) throws ModelDBException {
    GitCodeBlob newA = enforceOneof(a);
    GitCodeBlob newB = enforceOneof(b);
    GitCodeDiff d = DiffComputer.computeGitCodeDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    GitCodeBlob diffedB = DiffMerger.mergeGitCode(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeGitCode(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeNotebookCode(NotebookCodeBlob a, NotebookCodeBlob b)
      throws ModelDBException {
    NotebookCodeBlob newA = enforceOneof(a);
    NotebookCodeBlob newB = enforceOneof(b);
    NotebookCodeDiff d = DiffComputer.computeNotebookCodeDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    NotebookCodeBlob diffedB = DiffMerger.mergeNotebookCode(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeNotebookCode(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergePathDataset(PathDatasetBlob a, PathDatasetBlob b)
      throws ModelDBException {
    PathDatasetBlob newA = enforceOneof(a);
    PathDatasetBlob newB = enforceOneof(b);
    PathDatasetDiff d = DiffComputer.computePathDatasetDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    PathDatasetBlob diffedB = DiffMerger.mergePathDataset(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergePathDataset(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergePythonEnvironment(PythonEnvironmentBlob a, PythonEnvironmentBlob b)
      throws ModelDBException {
    PythonEnvironmentBlob newA = enforceOneof(a);
    PythonEnvironmentBlob newB = enforceOneof(b);
    PythonEnvironmentDiff d = DiffComputer.computePythonEnvironmentDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    PythonEnvironmentBlob diffedB = DiffMerger.mergePythonEnvironment(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergePythonEnvironment(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeS3Dataset(S3DatasetBlob a, S3DatasetBlob b) throws ModelDBException {
    S3DatasetBlob newA = enforceOneof(a);
    S3DatasetBlob newB = enforceOneof(b);
    S3DatasetDiff d = DiffComputer.computeS3DatasetDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    S3DatasetBlob diffedB = DiffMerger.mergeS3Dataset(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeS3Dataset(diffedB, d);
    assertEquals(newB, diffedB);
  }

  @Property
  public void diffAndMergeVersionEnvironment(VersionEnvironmentBlob a, VersionEnvironmentBlob b)
      throws ModelDBException {
    VersionEnvironmentBlob newA = enforceOneof(a);
    VersionEnvironmentBlob newB = enforceOneof(b);
    VersionEnvironmentDiff d = DiffComputer.computeVersionEnvironmentDiff(newA, newB);

    // Applying the diff on top of the original A should get original B
    VersionEnvironmentBlob diffedB = DiffMerger.mergeVersionEnvironment(newA, d);
    assertEquals(newB, diffedB);

    // Reapplying the diff should not change the result
    diffedB = DiffMerger.mergeVersionEnvironment(diffedB, d);
    assertEquals(newB, diffedB);
  }
}
